aspect SimpleClass {

    public HashSet<String> PTDummyClass.getDefinitionsRenamed() {
        return getOriginator().getDefinitionsRenamed(getExplicitlyRenamedDefinitions());
    }

    public HashMap<String,String> PTDummyClass.getRenamedDefinitionsMap(HashSet<String> conflicts) {
        HashMap<String,String> newDefinitions = getExplicitlyRenamedDefinitions();
        for (String conflictDef : conflicts) {
            String origClassName = getOrgID();
            // TODO template name here
            newDefinitions.put(conflictDef, String.format("super[%s].%s",
                                                          origClassName,conflictDef));
        }
        return newDefinitions;
    }
    // TODO use collections. maybe create a wrapper class for hashmap
    // for add(PTDummyRename) -> put(getOrgID(), getID())
    public HashMap<String,String> PTDummyClass.getExplicitlyRenamedDefinitions() {
        HashMap<String,String> map = new HashMap<String,String>();
        for (PTDummyRename entry : getPTDummyRenameList())
            map.put(entry.getOrgID(), entry.getID());
        return map;
    }

    public void SimpleClass.performMerging(LinkedList<PTDummyClass> dummies) {
        HashSet<String> conflicts = getConflicts(dummies);
        
        // kopier inn konflikter alla super[X].metodenavn
        //        assertAddsHasConstructor();
        //        LinkedList<ClassDecls> copies = getRenamedCopies(dummies,conflicts);        
        //        addNewDecls(copies);
        for (String conf : conflicts)
            System.out.println(getID() + " conflict: " + conf);
        if (assertAddsResolvesConflict(conflicts))
            for (PTDummyClass ext : dummies) 
                extendWithClassAndRename(ext,conflicts);
    }

    public boolean SimpleClass.assertAddsResolvesConflict(HashSet<String> conflicts) {
        HashSet<String> addRefinements = getClassDecl().getBodyDeclMethodNames();
        for (String conflictingName : conflicts) {
            if (addRefinements.contains(conflictingName)) {
                System.out.println(conflictingName + " is resolved in adds class.. ");
            } else {
                error(conflictingName + " is not resolved.. ");
                return false;
            }
        }
        return true;
    }

    // TOOD use google collections set operations
    public HashSet<String> SimpleClass.getConflicts(LinkedList<PTDummyClass> dummies) {
        HashSet<String>  collisions = new HashSet<String>();
        HashSet<String> allDefinisions = new HashSet<String>();
        
        for (PTDummyClass dummy : dummies) {
            HashSet<String> instanceDecls = dummy.getDefinitionsRenamed();
            HashSet<String> localCollisions = new HashSet<String>(instanceDecls);
            localCollisions.retainAll(allDefinisions);
            instanceDecls.removeAll(localCollisions);
            allDefinisions.addAll(instanceDecls);
            collisions.addAll(localCollisions);
        }
        return collisions;
        
    }
    
    public void SimpleClass.extendWithClassAndRename(PTDummyClass dummy, HashSet<String> conflicts) {
        try {
            ClassDecl ext = dummy.getOriginator().fullCopy();

            // Dette og en del av koden i addDecl kunne godt vært faktorert ut til noe mer fornuftigt
            String orgSuperClass = ext.getSuperClassName();
            String sourceClassName = ext.getID();
            ext.renameTypes(dummy.getInstDecl().getRenamedClasses());
            
            ext.renameDefinitions(dummy.getRenamedDefinitionsMap(conflicts));
            getClassDecl().signaturesCollides(ext);
            for (BodyDecl bd : ext.getBodyDecls()) {
                addDecl(sourceClassName, orgSuperClass, bd);
            }
        } catch (Exception e) { throw new RuntimeException("extendWithClass!: "+e); }
    }
    
    public void SimpleClass.addDecl(String sourceClassName, String orgSuperClass, BodyDecl decl) {
        ClassDecl target = getClassDecl();
        // special case with an empty constructor with no parameters and no code.
        // TODO: sjekk om det fortatt lages tomme konstruktører
        if (decl instanceof ConstructorDecl) { 
            ConstructorDecl cd = (ConstructorDecl) decl;
            if (cd.getNumParameter() == 0 && cd.getBlock().getNumStmt() == 0) {
                return;
            } else {
                try {
                   decl = cd.toMethodDecl(target.getID(), "super" + sourceClassName, orgSuperClass);
                   target.addBodyDecl(decl);
                   return;
                }
                catch (Exception e) {
                    cd.error("Could not rewrite constructor " + cd.dumpString() + " to method during class merging.");
                }
            }
        }

        for (BodyDecl bd : target.getBodyDecls()) {
            if (bd.getClass().isInstance(decl) && decl.equalSignature(bd)) {
                if (bd.originallyFromAddsClass==true && decl.wasExplicitlyRenamed ==false && decl instanceof MethodDecl) {
                    MethodDecl md = (MethodDecl)decl;
                    md.setID("super" + sourceClassName + "_" + md.getID());
                    md.wasAutoRenamed = true;
                    target.addBodyDecl(md);
                    return;
                }
                else if (decl.wasExplicitlyRenamed==true) {
                    decl.error(decl.dumpString() + " was explicitly renamed, but collided with " + bd.dumpString());
                    return;
                }
                else {
                    decl.error("Tried to replace " + bd.dumpString() + " with " + decl.dumpString());
                    return;
                }
            }
        }
        target.addBodyDecl(decl);
    }
}
