aspect InstantiationRewrite {

    private boolean PTDecl.isRewritten = false;

    rewrite PTDecl {
        when ( this.isRewritten == false)
        to PTDecl {
            for (PTInstDecl templateInst : getPTInstDecls()) {
                List<PTDummyClass> allDummyClasses = templateInst.getCompleteDummyClassSet();
                for (PTDummyClass dummy : allDummyClasses) {
                    ClassDecl temp = dummy.getOriginator().fullCopy();
                    PTClassDecl newClass = new PTClassDecl(temp);
                    newClass.renameTypes(templateInst.getRenamedClasses());
                    addSimpleClass(newClass);
                    PTClassAddsDecl extension = lookupAddClass(newClass.getID());
                    if (extension != null) {
                        newClass.extendWithAddClass(extension);
                        // extension.removeSelf();
                    }
                }
            }
            //System.out.println("got rewrite for " + getID() + " => " + getID());
            this.isRewritten = true;
            return this;
        }
    }

    public void PTClassDecl.extendWithAddClass(PTClassAddsDecl extension) {
        try {
            for (BodyDecl bd : extension.getBodyDecls()) {
                addDecl(bd.clone());
            }            
        } catch (Exception e) { throw new RuntimeException("extendWithAddClass!: "+e); }
    }

    public void PTClassDecl.addDecl(BodyDecl decl) {
        ClassDecl target = getClassDecl();
        // special case with an empty constructor with no parameters and no code.
        // TODO: sjekk om det fortatt lages tomme konstruktører
        if (decl instanceof ConstructorDecl) { 
            ConstructorDecl cd = (ConstructorDecl) decl;
            if (cd.getNumParameter()==0 && cd.getBlock().getNumStmt() == 0) return;
        }

        for (BodyDecl bd : target.getBodyDecls()) {
            //            if (bd.getClass().isInstance(decl) && this.equalSignature(bd)) {
            if (decl.equalSignature(bd)) {
                bd.replaceSelfWith(decl);
                return;
            }
        }
        target.addBodyDecl(decl);
    }

    public void ASTNode.replaceSelfWith(ASTNode replacement) {
        ASTNode parent = getParent();
        int i = parent.getIndexOfChild(this);
        parent.setChild(replacement, i);
    }


    public String ASTNode.scopeSignature() { throw new RuntimeException("No scopeSignature for Class " + getClass().getName()); }
    public String FieldDeclaration.scopeSignature() { return getID(); } // nok med ID som navn siden vi også sjekker på klassetype
    public String ConstructorDecl.scopeSignature() { return descName(); }
    public String MethodDecl.scopeSignature() {
        String _static = getModifiers().isStatic() ? "static" : "instance";
        return _static + "_" + descName();
    }
    public String MemberClassDecl.scopeSignature() { return getClassDecl().getID(); }

    public boolean ASTNode.equalSignature(ASTNode other) {
        boolean res = this.scopeSignature().equals(other.scopeSignature());
        //System.out.println(this.dumpTreeNoRewrite() + "\n::vs::\n" + other.dumpTreeNoRewrite() + "\n====> " + res);
        //System.out.println(this.scopeSignature() + " ::vs:: " + other.scopeSignature() + " => " + res);
        return res;
    }

    // TODO:
    // Her på scopeSignature() mangler det nok en del spesialiseringer.
    // Mer presist navn på 'scopeSignature()'?
    // Les mer her: http://java.sun.com/docs/books/jls/second_edition/html/names.doc.html#33757

    // BUG:
    // Siden dette blir gjort 'iterativt', altså mulig erstatning for hver ny gjennomløping,
    // så vil det kunne bli en erstatning av seg selv. Altså en del av Adds klassen kan
    // utilsiktet og uten advarsel overskrive seg selv. Kan fikses med å bruke én gjennom-
    // løping og sets som Eivind foreslo.

    public void ASTNode.removeSelf() {
        ASTNode parent = getParent();
        parent.removeChild(parent.getIndexOfChild(this));
    }

    public List<PTDummyClass> PTInstDecl.getCompleteDummyClassSet() {
        HashMap<String,String> renamedClasses = getRenamedClasses();
        LinkedList<ClassDecl> templateClasses = getTemplate().getClassList();
        List<PTDummyClass> dummies = getPTDummyClassList();
        for (ClassDecl templateClass: templateClasses) {
            String templateID = templateClass.getID();
            if (!renamedClasses.containsKey(templateID)) {
                PTDummyClass dummy = new PTDummyClass(templateID, templateID);
                dummies.add(dummy);
            }
        }
        return dummies;
    }
}
