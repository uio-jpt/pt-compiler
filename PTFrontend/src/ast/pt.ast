PTCompilationUnit : CompilationUnit ::= PTDecl*;

abstract PTDecl ::= <ID> PTInstDecl* SimpleClass* PTInterfaceDecl* PTEnumDecl*;
PTTemplate : PTDecl ::= TypeParameter:TypeVariable*;
PTPackage : PTDecl;

abstract SimpleClass ::= ClassDecl;
PTClassDecl : SimpleClass;
PTClassAddsDecl : SimpleClass;

PTInterfaceDecl : InterfaceDecl;
PTInterfaceAddsDecl : PTInterfaceDecl;

PTEnumDecl : EnumDecl;

PTInstDecl ::= <ID> TypeArgument:Access* PTInstTuple*;
// inst T<...> with A => X;
//      ID  typevariables   PTInstTuple

PTInstTuple ::= <OrgID> <ID> PTDummyRename*;

PTTSuperConstructorCall ::= <SuperTemplateID> <TemplateSuperclassID> Arg:Expr*;
PTConstructorDecl : ConstructorDecl ::= TSuperConstructorInvocation:PTTSuperConstructorCall*;

abstract PTDummyRename ::= <OrgID> <ID>;
PTMethodRename : PTDummyRename ::= Access*;
PTMethodRenameAll : PTDummyRename;
PTFieldRename : PTDummyRename;

abstract PTMethodAccess : MethodAccess;

// e.g. tsuper[<templateName>.<ClassName>].f()
TemplateMethodAccess : PTMethodAccess ::= <TClassID> <TemplateID>;
// e.g. tsuper[<ClassName>].f()
// will be converted to superType if unambigous
TemplateMethodAccessShort : TemplateMethodAccess;

// The template constructors call chain is generated and it's not legal or
// possible for the end user to call those constructors/methods
TemplateConstructorAccess : PTMethodAccess ::= <TClassID> <TemplateID>;

/* A constructor defined in a template will be transformed to a 
 * method of type TemplateConstructor when it is instantiated.
 */
TemplateConstructor : MethodDecl ::= <TClassID> <TemplateID>;

/* Constructors of a class in a package will be transformed to this type.
 * PackageConstructors acceps arguments as opposed to TemplateConstructor.
 */
PackageConstructor : MethodDecl ::= <TClassID> <TemplateID>;

/* Type that marks a method as tabstract.
 */ 
TabstractMethodDecl : MethodDecl;
