aspect RequiredTypes {
  public void ASTNode.replaceTypeAccesses(Map<TypeDecl,TypeAccess> ht) {
        for(int i = 0; i < getNumChild(); i++) {
            ASTNode child = getChild(i);
            TypeAccess swapWith = child.visitReplaceTypeAccesses(ht);
            if ( swapWith != null ) {
                child.replaceSelfWith( swapWith.fullCopy() );
            }
            getChild(i).replaceTypeAccesses(ht);
        }
  }

  public TypeAccess ASTNode.visitReplaceTypeAccesses(Map<TypeDecl,TypeAccess> ht) {
    return null;
  }

  public TypeAccess TypeAccess.visitReplaceTypeAccesses(Map<TypeDecl,TypeAccess> ht) {
    TypeDecl myDecl = decl();
    return ht.get( myDecl );
  }

  public boolean RequiredType.isObject() {
      // not called?
      return true;
  }

  public TypeConstraint RequiredType.getTypeConstraint() {
      TypeConstraint rv = new TypeConstraint();

      if( this instanceof RequiredClass ) {
          rv.requireClass();
      }
      if( this instanceof RequiredInterface ) {
          rv.requireInterface();
      }

      return rv;
  }

  public boolean RequiredType.instanceOf( TypeDecl that ) {
      if( typeObject().instanceOf( that ) ) {
          return true;
      }
      // TODO use nominal superclasses!
      return false;
  }

  public boolean BodyDecl.isInRequiredType() {
    return getParentClass( RequiredType.class ) != null;
  }



    /* What's the proper way to do this (i.e. how is it done in J.a.J. for interfaces?
       Not trivial to figure out so this works for now. */
  rewrite 
    MethodDecl 
    {
        when ( isInRequiredType() && !isAbstract() )
        to MethodDecl
      {
            getModifiers().addModifier( new Modifier( "abstract" ) );
            return this;
      }
    }

    eq RequiredType.methodsSignatureMap() {
        HashMap map = new HashMap( localMethodsSignatureMap() );

        System.out.println( "WOOO" + map );

        return map;
    }


    // the equivalents for JastaddJ are in SyntacticClassification.jrag
    eq RequiredType.getSuperTypeAccess().nameType() = NameType.TYPE_NAME;
    eq RequiredType.getImplements().nameType() = NameType.TYPE_NAME;

    public void PTAbstractConstructor.nameCheck() {
        super.nameCheck();

        RequiredType reqtype = (RequiredType) getParentClass( RequiredType.class );
        if( reqtype != null ) {
            if( ! reqtype.getID().equals( getID() ) ) {
                error( "defining abstract constructor of conflicting name " + getID() + " in required type " + reqtype.getID() );
            }
        } else {
            error( "required type-abstract constructor outside required type (impossible)" );
        }
    }

}
