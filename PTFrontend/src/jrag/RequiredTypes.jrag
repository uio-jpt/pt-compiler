aspect RequiredTypes {
  public void ASTNode.replaceTypeAccesses(Map<TypeDecl,Access> ht) {
        for(int i = 0; i < getNumChild(); i++) {
            ASTNode child = getChild(i);
            ASTNode swapWith = child.visitReplaceTypeAccesses(ht);
            if ( swapWith != null ) {
                child.replaceSelfWith( swapWith.fullCopy() );
            }
            getChild(i).replaceTypeAccesses(ht);
        }
  }

  public ASTNode ASTNode.visitReplaceTypeAccesses(Map<TypeDecl,Access> ht) {
    return null;
  }

  public ASTNode TypeAccess.visitReplaceTypeAccesses(Map<TypeDecl,Access> ht) {
    SimpleSet myDecls = decls();
    if( myDecls.size() == 1 ) {
        TypeDecl myDecl = decl();
        Access rv = ht.get( myDecl );
        return rv;
    } else {
        System.out.println( "warning access has " + myDecls.size() + " decls" );
        System.out.println( "access is: " + dumpTree() );
        System.out.println( "access is string: " + this );
        return null;
    }
  }

  public boolean RequiredType.isObject() {
      // not called?
      return true;
  }

  public TypeConstraint RequiredType.getTypeConstraint() {
      TypeConstraint rv = new TypeConstraint();

      if( this instanceof RequiredClass ) {
          rv.requireClass();
      }
      if( this instanceof RequiredInterface ) {
          rv.requireInterface();
      }

      if( hasSuperTypeAccess() ) {
          rv.addSuperType( new JastaddTypeDescriptor( getSuperTypeAccess() ) );
      }

      for( Access a : getImplementsList() ) {
          TypeAccess ta = (TypeAccess) a;
          TypeDecl td = ta.decl();

          rv.addImplementedType( new JastaddTypeDescriptor( td ) );
      }


      for( BodyDecl bd : getBodyDecls() ) {
          JastaddTypeConstraints.fromRequiredTypeBodyDeclInto( bd, rv );
      }

      System.out.println( "constructed " + rv );

      return rv;
  }

  public boolean RequiredType.instanceOf( TypeDecl that ) {
      if( typeObject().instanceOf( that ) ) {
          return true;
      }
      // TODO use nominal superclasses!
      return false;
  }

  public boolean BodyDecl.isInRequiredType() {
    return getParentClass( RequiredType.class ) != null;
  }


  rewrite PTAbstractConstructor {
      when ( getID().equals("$UNNAMED-CONSTRUCTOR$") )
      to PTAbstractConstructor {
          RequiredType parent = (RequiredType) getParentClass( RequiredType.class );
          if( parent == null ) {
              setID( "$INVALID$" ); // oops
          } else {
              setID( parent.getID() );
          }

          return this;
      }
  }


    /* What's the proper way to do this (i.e. how is it done in J.a.J. for interfaces?
       Not trivial to figure out so this works for now. */
  rewrite 
    MethodDecl 
    {
        when ( isInRequiredType() && !isAbstract() )
        to MethodDecl
      {
            getModifiers().addModifier( new Modifier( "abstract" ) );
            return this;
      }
    }

    eq RequiredType.methodsSignatureMap() {
        HashMap map = new HashMap( localMethodsSignatureMap() );

        if( hasSuperTypeAccess() ) {
            TypeDecl superType = Util.declarationFromTypeAccess( getSuperTypeAccess() );
            if( superType != null ) {
                  for(Iterator iter = superType.methodsIterator(); iter.hasNext(); ) {
                    MethodDecl m = (MethodDecl)iter.next();
                    if(!m.isPrivate() && m.accessibleFrom(this) && !localMethodsSignatureMap().containsKey(m.signature()))
                      putSimpleSetElement(map, m.signature(), m);
                  }
            }
        }

        for( Access a : getImplementsList() ) {
            TypeAccess ta = (TypeAccess) a;
            TypeDecl td = ta.decl();
            if( td == null ) continue;

            // this should be either a RequiredType (RequiredInterface) or
            // a real interface

      for(Iterator iter = td.methodsIterator(); iter.hasNext(); ) {
        MethodDecl m = (MethodDecl)iter.next();
        if(!m.isPrivate() && m.accessibleFrom(this) && !localMethodsSignatureMap().containsKey(m.signature()))
          putSimpleSetElement(map, m.signature(), m);
      }


        }

        return map;
    }


    // the equivalents for JastaddJ are in SyntacticClassification.jrag
    eq RequiredType.getSuperTypeAccess().nameType() = NameType.TYPE_NAME;
    eq RequiredType.getImplements().nameType() = NameType.TYPE_NAME;
    eq RequiredTypeInstantiation.getConcreteTypeAccess().nameType() = NameType.TYPE_NAME;

    public void PTAbstractConstructor.nameCheck() {
        super.nameCheck();

        RequiredType reqtype = (RequiredType) getParentClass( RequiredType.class );
        if( reqtype != null ) {
            if( ! reqtype.getID().equals( getID() ) ) {
                error( "defining abstract constructor of conflicting name " + getID() + " in required type " + reqtype.getID() );
            }

            if( ! (reqtype instanceof RequiredClass) ) {
                error( "defining abstract constructor in required non-class (type or interface)" );
            }
        } else {
            error( "required type-abstract constructor outside required type (impossible)" );
        }
    }

    public Access RequiredType.getSuperTypeAccessOrNull() {
        return hasSuperTypeAccess() ? getSuperTypeAccess() : null;
    }

    public boolean RequiredType.isExtendsCircular() {
        // circularity not in the RT part will be detected by JaJ
        Set<RequiredType> extendedRTs = new HashSet<RequiredType>() ;
        Access nextSuper = getSuperTypeAccessOrNull();
        extendedRTs.add( this );
        while( nextSuper != null ) {
            TypeDecl decl = Util.declarationFromTypeAccess( nextSuper );
            if( !(decl instanceof RequiredType) ) break;
            if( extendedRTs.contains( decl ) ) {
                return true;
            }
            extendedRTs.add( (RequiredType) decl );

            nextSuper = ((RequiredType) decl).getSuperTypeAccessOrNull();
        }
        return false;
    }

    public boolean RequiredType.isLocallyImplementsCircular( Set<RequiredType> forbidden ) {
        for( RequiredType rt : getImplementedRequiredTypes() ) {
            if( forbidden.contains( rt ) ) {
                return true;
            }

            Set<RequiredType> newForbidden = new java.util.HashSet<RequiredType> ( forbidden );
            newForbidden.add( rt );
            
            if( rt.isLocallyImplementsCircular( newForbidden ) ) {
                return true;
            }
        }
        return false;
    }

    public boolean RequiredType.isImplementsCircular() {
        // circularity not in the RT part will be detected by JaJ
        Set<RequiredType> extendedRTs = new HashSet<RequiredType>() ;
        extendedRTs.add( this );
        return isLocallyImplementsCircular( extendedRTs );
    }

    public java.util.List<RequiredType> RequiredType.getImplementedRequiredTypes() {
        java.util.List<RequiredType> rv = new java.util.ArrayList<RequiredType>();
        for( Access a : getImplementsList() ) {
            TypeDecl d = Util.declarationFromTypeAccess( a );
            if( d != null ) {
                if( d instanceof RequiredType ) {
                    rv.add( (RequiredType) d );
                }
            }
        }
        return rv;
    }

    public void RequiredType.nameCheck() {
        super.nameCheck();

        if( isExtendsCircular() ) {
            error( "required type " + getID() + " has circular extends chain" );
        }

        if( isImplementsCircular() ) {
            error( "required type " + getID() + " has circular implements chain" );
        }
    }

    eq RequiredType.getSuperTypeAccess().lookupType(String name) {
        return lookupType( name );
    }

    public String RequiredType.toString() {
        return "[required type " + getID() + "]";
    }

}
