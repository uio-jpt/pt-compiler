import testutils.utils.CriticalPTException;

aspect ErrorCheck {

    /* what does this do? */
  // public void ClassInstanceExpr.collectErrors() {
  //     // skipping namecheck for templates
  //     //    nameCheck();
  //   typeCheck();
  //   accessControl();
  //   exceptionHandling();
  //   checkUnreachableStmt();
  //   definiteAssignment();
  //   checkModifiers();
  //   for(int i = 0; i < getNumChild(); i++) {
  //     getChild(i).collectErrors();
  //   }
  // }

    public void TemplateConstructor.typeCheck() {
        super.typeCheck();
        if (getNumParameter() > 0) {
            error("Template Constructors aren't allowed to have parameters.");
        }
    }

    refine Generics public void TypeDecl.typeCheck() {
        Generics.TypeDecl.typeCheck();

        PTDecl enclosingPTDecl = (PTDecl) getParentClass( PTDecl.class );
        TypeDecl enclosingType = (TypeDecl) getParentClass( TypeDecl.class );
        MethodDecl enclosingMethod = (MethodDecl) getParentClass( MethodDecl.class );
        
        if( enclosingPTDecl != null ) {
            boolean isLocalToMethod = (enclosingMethod != null) && (enclosingMethod.getParentClass( TypeDecl.class ) == enclosingType); 
            if( !isLocalToMethod ) {
                boolean isLocalToType = enclosingType != null;
                if( isLocalToType ) {
                    error( "implementation restriction -- nested classes (" + getID() + " nested in " + enclosingType.getID() + ") are disallowed in JPT" );
                }
            }
        }
    }

    refine TypeCheck public void  ClassInstanceExpr.typeCheck() {
        TypeCheck.ClassInstanceExpr.typeCheck();
        // check that expr is not a template class if new expr is made
        // from within a template class and its list of arguments is
        // greater than 1.
        if ( getNumArg() > 0 && getParentClass(PTTemplate.class) != null) {
			TypeAccess t = (TypeAccess) getAccess();
        	if (!localLookupType(t.getID()).isEmpty()) { 
            // TODO make this check only for new TemplateClass calls.
            // example, new LinkedList(oldLinkedList); should work.
            error("New calls in templates only allowed without arguments.");
        	}
        }
    }

    refine ErrorCheck public void ASTNode.collectErrors() {
        try{
            ErrorCheck.ASTNode.collectErrors();
        } catch (CriticalPTException e) {
            
        }
    }

    public void TabstractMethodDecl.typeCheck() {
        if (getParentClass(PTPackage.class) != null) {
            if(hostType().methodsSignature(signature()) == SimpleSet.emptySet) {
                error("Tabstract method must be implemented before or in the instantiating package class.");
            }
        }
    }
}
