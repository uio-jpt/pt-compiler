import testutils.utils.CriticalPTException;

aspect ErrorCheck {

    /* what does this do? */
  // public void ClassInstanceExpr.collectErrors() {
  //     // skipping namecheck for templates
  //     //    nameCheck();
  //   typeCheck();
  //   accessControl();
  //   exceptionHandling();
  //   checkUnreachableStmt();
  //   definiteAssignment();
  //   checkModifiers();
  //   for(int i = 0; i < getNumChild(); i++) {
  //     getChild(i).collectErrors();
  //   }
  // }


/* // disabled sep 30, going back to backwards E
    public void TemplateConstructor.typeCheck() {
        super.typeCheck();
        if (getNumParameter() > 0) {
            error("Template Constructors aren't allowed to have parameters.");
        }
    }
*/

    refine Generics public void TypeDecl.typeCheck() {
        Generics.TypeDecl.typeCheck();

        PTDecl enclosingPTDecl = (PTDecl) getParentClass( PTDecl.class );
        TypeDecl enclosingType = (TypeDecl) getParentClass( TypeDecl.class );
        MethodDecl enclosingMethod = (MethodDecl) getParentClass( MethodDecl.class );
        
        if( enclosingPTDecl != null ) {
            boolean isLocalToMethod = (enclosingMethod != null) && (enclosingMethod.getParentClass( TypeDecl.class ) == enclosingType); 
            if( !isLocalToMethod ) {
                boolean isLocalToType = enclosingType != null;
                if( isLocalToType ) {
                    error( "implementation restriction -- nested classes (" + getID() + " nested in " + enclosingType.getID() + ") are disallowed in JPT" );
                }
            }
        }
    }

    refine TypeCheck public void  ClassInstanceExpr.typeCheck() {
        TypeCheck.ClassInstanceExpr.typeCheck();
        // check that expr is not a template class if new expr is made
        // from within a template class and its list of arguments is
        // greater than 1.
        if ( getNumArg() > 0 && getParentClass(PTTemplate.class) != null) {
			TypeAccess t = (TypeAccess) getAccess();
        	if (!localLookupType(t.getID()).isEmpty()) { 
            // TODO make this check only for new TemplateClass calls.
            // example, new LinkedList(oldLinkedList); should work.
            error("New calls in templates only allowed without arguments.");
        	}
        }
    }

    refine ErrorCheck public void ASTNode.collectErrors() {
        try{
            ErrorCheck.ASTNode.collectErrors();
        } catch (CriticalPTException e) {
            
        }
    }

    public void TabstractMethodDecl.typeCheck() {
        if (getParentClass(PTPackage.class) != null) {
            if(hostType().methodsSignature(signature()) == SimpleSet.emptySet) {
                error("Tabstract method must be implemented before or in the instantiating package class.");
            }
        }
    }

    public void PTTSuperConstructorCall.collectErrors() {
        /* This is a hack (XXX), yet still --
           PTTSuperConstructorCall is simply a statement to the PT compiler, wrapping essentially a Java statement.
           The Java statement is copied into the place where it belongs and will be errorchecked there.
           So we don't really need error checking here (which would require giving the PTTSuperConstructorCall
           proper scope and so on.

           (To be clear, by overloading this method and not calling the overloaded method, we are
           turning off error checking within the subtree of the AST rooted by PTTSuperConstructorCall)
        */
    }
}
