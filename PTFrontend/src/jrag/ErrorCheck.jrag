import testutils.utils.CriticalPTException;

aspect ErrorCheck {

    /* what does this do? */
  // public void ClassInstanceExpr.collectErrors() {
  //     // skipping namecheck for templates
  //     //    nameCheck();
  //   typeCheck();
  //   accessControl();
  //   exceptionHandling();
  //   checkUnreachableStmt();
  //   definiteAssignment();
  //   checkModifiers();
  //   for(int i = 0; i < getNumChild(); i++) {
  //     getChild(i).collectErrors();
  //   }
  // }


/* // disabled sep 30, going back to backwards E
    public void TemplateConstructor.typeCheck() {
        super.typeCheck();
        if (getNumParameter() > 0) {
            error("Template Constructors aren't allowed to have parameters.");
        }
    }
*/

    refine Generics public void TypeDecl.typeCheck() {
        Generics.TypeDecl.typeCheck();

        PTDecl enclosingPTDecl = (PTDecl) getParentClass( PTDecl.class );
        TypeDecl enclosingType = (TypeDecl) getParentClass( TypeDecl.class );
        MethodDecl enclosingMethod = (MethodDecl) getParentClass( MethodDecl.class );
        
        if( enclosingPTDecl != null ) {
            boolean isLocalToMethod = (enclosingMethod != null) && (enclosingMethod.getParentClass( TypeDecl.class ) == enclosingType); 
            if( !isLocalToMethod ) {
                boolean isLocalToType = enclosingType != null;
                if( isLocalToType ) {
                    error( "implementation restriction -- nested classes (" + getID() + " nested in " + enclosingType.getID() + ") are disallowed in JPT" );
                }
            }
        }
    }

    refine TypeCheck public void  ClassInstanceExpr.typeCheck() {
        TypeCheck.ClassInstanceExpr.typeCheck();
        // check that expr is not a template class if new expr is made
        // from within a template class and its list of arguments is
        // greater than 1.
        if ( getNumArg() > 0 && getParentClass(PTTemplate.class) != null) {
			TypeAccess t = (TypeAccess) getAccess();
        	if (!localLookupType(t.getID()).isEmpty()) { 
            // TODO make this check only for new TemplateClass calls.
            // example, new LinkedList(oldLinkedList); should work.
            error("New calls in templates only allowed without arguments.");
        	}
        }
    }

    refine ErrorCheck public void ASTNode.collectErrors() {
        try{
            ErrorCheck.ASTNode.collectErrors();
        } catch (CriticalPTException e) {
            
        }
    }

    public void TabstractMethodDecl.typeCheck() {
        if (getParentClass(PTPackage.class) != null) {
            if(hostType().methodsSignature(signature()) == SimpleSet.emptySet) {
                error("Tabstract method must be implemented before or in the instantiating package class.");
            }
        }
    }

    public void SuperConstructorAccess.collectErrors() {
        super.collectErrors();
        PTTemplate parentTemplate = (PTTemplate) getParentClass( PTTemplate.class );
        EnumDecl parentEnum = (EnumDecl) getParentClass( EnumDecl.class );
        if( parentEnum != null ) {
            /* Exception for enums: these generate a class implicity, and in the code for
               this call a superconstructor java.lang.Enum(String,int).

               Being able to do this from templates seems like the only sensible choice?
               */
            return;
        }
        if( parentTemplate != null ) {
            error( "calling super-constructor in template class (should be called from instantiating package)" );
        }
    }

    protected boolean PTConstructorDecl.tsupersWereExpanded = false;

    rewrite PTConstructorDecl {
            when (this.tsupersWereExpanded == false)
            to PTConstructorDecl {
                PTDecl parentPt = (PTDecl) getParentClass( PTDecl.class );
                java.util.List<ASTNode> tparents = parentPt.getTemplateDeclarationsMergedTo( getClassDecl().getID() );
                java.util.Map<String, PTTemplate> templatesMap = parentPt.getInstantiatedTemplatesMap();
                java.util.Map<PTTemplate, ASTNode> uncalled = new java.util.HashMap<PTTemplate, ASTNode>();

                for( ASTNode tparent : tparents ) {
                    PTTemplate template = (PTTemplate) tparent.getParentClass( PTTemplate.class );
                    uncalled.put( template, tparent );
                }
                for( PTTSuperConstructorCall scc : getTSuperConstructorInvocationList() ) {
                    PTTemplate template = templatesMap.get( scc.getSuperTemplateID() );
                    uncalled.remove( template );
                }
                for( PTTemplate template : uncalled.keySet() ) {
                    ASTNode node = uncalled.get( template );
                    ClassDecl cd = (ClassDecl) node;
                    boolean hasZeroArityConstructor = false;
                    for( ConstructorDecl consd : cd.getConstructorDeclList() ) {
                        if( consd.arity() > 0 ) continue;
                        hasZeroArityConstructor = true;
                    }

                    if( hasZeroArityConstructor ) {
                        PTTSuperConstructorCall myCall = new PTTSuperConstructorCall( template.getID(), cd.getID(), new AST.List() );

                        // added in arbitrary order!
                        addTSuperConstructorInvocation( myCall );
                    }
                }

                this.tsupersWereExpanded = true;
                return this;
            }
    }

    refine NameCheck public void ParameterDeclaration.nameCheck() {
        if( getParentClass( PTConstructorPromise.class ) != null ) {
            return;
        } else {
            NameCheck.ParameterDeclaration.nameCheck();
        }
    }

    refine Enums public void ClassInstanceExpr.nameCheck() {
        boolean doNormalChecking = true;

        PTTemplate template = (PTTemplate) getParentClass( PTTemplate.class );
        EnumDecl parentEnum = (EnumDecl) getParentClass( EnumDecl.class );
        if( template != null && parentEnum == null ) {
            TypeDecl t = getAccess().type();
            if( t.getParentClass( PTTemplate.class ) == template ) {
                doNormalChecking = false;

                boolean foundGood = false;

                for( PTConstructorPromise promise : t.promisedConstructors() ) {
                    if( promise.matchesConstructorInvocation( this ) ) {
                        foundGood = true;
                    }
                }

                if( !foundGood ) {
                    error( "no such constructor assumed" );
                }
            }

        }

        if( doNormalChecking ) {
            Enums.TypeDecl.nameCheck();
        }
    }

    public void PTConstructorDecl.checkTSuperConstructorInvocations() {
        PTDecl parentPt = (PTDecl) getParentClass( PTDecl.class );

        boolean hasDelegatedToThis = false;

        if( hasConstructorInvocation() ) {
            Stmt invoc = getConstructorInvocation();
            if( invoc instanceof ExprStmt ) {
                ExprStmt einvoc = (ExprStmt) invoc;
                Expr expr = einvoc.getExpr();
                if( expr instanceof ConstructorAccess ) {
                    ConstructorAccess cacc = (ConstructorAccess) expr;

                    if( cacc.getID().equals( "this" ) ) {
                        hasDelegatedToThis = true;
                    }
                }
            }
        }

        if( hasDelegatedToThis ) {
            if( getNumTSuperConstructorInvocation() > 0 ) {
                error( "constructor contains both call to this() and tsuper constructor invocation(s)" );
            }
            return;
        }

        if( parentPt != null ) {
            java.util.List<ASTNode> tparents = parentPt.getTemplateDeclarationsMergedTo( getClassDecl().getID() );

            java.util.Set<PTTemplate> uncalled = new java.util.HashSet<PTTemplate>();
            java.util.Set<ASTNode> called = new java.util.HashSet<ASTNode>();

            java.util.Map<String, PTTemplate> templatesMap = parentPt.getInstantiatedTemplatesMap();

            for( ASTNode tparent : tparents ) {
                PTTemplate template = (PTTemplate) tparent.getParentClass( PTTemplate.class );
                uncalled.add( template );
            }

            for( PTTSuperConstructorCall scc : getTSuperConstructorInvocationList() ) {
                PTTemplate template = templatesMap.get( scc.getSuperTemplateID() );
                SimpleSet decls = template.ptLookupTypeIn( scc.getTemplateSuperclassID() );
                if( decls.size() == 1 ) {
                    ASTNode decl = (ASTNode) decls.iterator().next();

                    uncalled.remove( template );

                    if( called.contains( decl ) ) {
                        scc.error( "tsuper-constructor called twice" );
                    } else {
                        called.add( decl );
                    }


                    // TODO check that there's a constructor with matching parameters
                    // not urgent, because this leads to an error message
                    // involving minit$ methods later already
                }
            }
            
            for( PTTemplate decl : uncalled ) {
                error( "tsuper constructor from " + decl.getID() + " not called" );
            }
        }
    }

    public void ClassDecl.collectErrors() {
        super.collectErrors();

        checkConstructorPromises();
    }

    public void PTConstructorDecl.collectErrors() {
        super.collectErrors();

        checkTSuperConstructorInvocations();
    }

    public void PTTSuperConstructorCall.collectErrors() {
        /* This is a hack (XXX), yet still --
           PTTSuperConstructorCall is simply a statement to the PT compiler, wrapping essentially a Java statement.
           The Java statement is copied into the place where it belongs and will be errorchecked there.
           So we don't really need error checking here (which would require giving the PTTSuperConstructorCall
           proper scope and so on.

           (To be clear, by overloading this method and not calling the overloaded method, we are
           turning off error checking within the subtree of the AST rooted by PTTSuperConstructorCall)
        */
    }
}
