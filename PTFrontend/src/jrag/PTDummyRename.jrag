/**
   This part might be rewritten.. maybe even put in javaworld.
   much of this signature stuff is done elsewhere.
 */
aspect PTDummyRename {

    inh TypeDecl PTDummyRename.getOriginatorClass();
    eq PTInstTuple.getPTDummyRename(int i).getOriginatorClass() = getOriginator();
    
    eq PTMethodRename.getAccess(int i).lookupType(String name) {
        return getOriginatorClass().lookupType(name);
    }

    eq PTMethodRename.getAccess(int i).nameType() = NameType.TYPE_NAME;

    syn String PTDummyRename.getSignature();

    eq PTMethodRename.getSignature() = getOldSignature();

    eq PTMethodRenameAll.getSignature() = getOrgID() + "(*)";

    eq PTFieldRename.getSignature() = getOrgID();

    syn String PTMethodRename.getCustomSignature(String name) {
        StringBuffer sig = new StringBuffer(name + "(" );
        Iterator iter = getAccessList().iterator();
        while (iter.hasNext()) {
            sig.append(iter.next());
            if (iter.hasNext())
                sig.append(", ");
        }
        sig.append(")");
        return sig.toString();
    }

    syn String PTMethodRename.getOldSignature() = getCustomSignature(getOrgID());
    syn String PTMethodRename.getNewSignature() = getCustomSignature(getID());    

/*

    // These have been disabled because they give false positives, e.g.:
    // java.lang.Runnable vs Runnable. They have been disabled instead of
    // "repaired" because I believe that a String-based model is fundamentally
    // flawed. Functionality is moving into javaworld as suggested by
    // top comment.

    public void PTMethodRename.nameCheck() {
        if (!getOriginatorClass().methodsSignatureMap().containsKey(getSignature()))
            error("Method with signature " + getSignature() + " not found in originating class " +
                  getOriginatorClass().getID() + ".\n");
    }

    public void PTMethodRenameAll.nameCheck() {
        if (!getOriginatorClass().methodNames().contains(getOrgID()))
            error("No method with name " + getOrgID() + " found in originating class " +
                  getOriginatorClass().getID() + ".\n");
    }

    */

    public void PTFieldRename.nameCheck() {
        if (!getOriginatorClass().memberFieldsMap().containsKey(getSignature()))
            error("Field " + getSignature() + " not found in originating class " +
                  getOriginatorClass().getID() + ".\n");

    }

    public void PTDummyRename.addSelfTo(Map<String,String> renameMap) {
        renameMap.put(getSignature(), getID());
    }

    public void PTMethodRename.addSelfTo(Map<String,String> renameMap) {
        renameMap.put(getOldSignature(), getNewSignature());
    }
    
    public void PTMethodRenameAll.addSelfTo(Map<String,String> renameMap) {
        String methodName = getOrgID();
        for (String originalSignature : getOriginatorClass().methodSignatures())
            if (originalSignature.startsWith(methodName))
                renameMap.put(originalSignature, getID());
    }
    

}
