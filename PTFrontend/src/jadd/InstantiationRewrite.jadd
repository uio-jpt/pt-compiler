import javaworld.InstantiationRewriter;
import javaworld.Util;
import com.google.common.collect.Multimap;
import com.google.common.collect.Iterables;
import testutils.tester.Log;


aspect InstantiationRewrite {

    protected boolean PTDecl.isRewritten = false;
    protected boolean PTInstDecl.isRewritten = false;

    private Multimap<String,String> ClassDecl.templateClassIDTotemplateID;

    public void ClassDecl.setClassToTemplateMap(Multimap<String,String> x) {
        templateClassIDTotemplateID = x;
    }

    public String ClassDecl.lookupTemplateForTClass(String tclassID) {
        Collection<String> x = templateClassIDTotemplateID.get(tclassID);
        return Iterables.getOnlyElement(x);
    }
        

    rewrite PTInstDecl {
        when (this.isRewritten == false && templateIsRewritten())
            // templateIsRewritten() refers to the source template of this
            // PTInstDecl and not the template that contains it, meaning
            // that PTInstDecl will be rewritten before it's containing
            // template or package is rewritten.
        to PTInstDecl {
            Log.d("JPT:Rewrite:PTInstDecl", "Rewriting PTInstDecl " + this.getName() + " :: Started");
            Log.d("JPT:Rewrite:PTInstDecl", "Scope was: " + showParentsAndSelf());
            this.isRewritten = true;
            addMissingDummyClassNodes();
            Log.d("JPT:Rewrite:PTInstDecl", "Rewriting PTInstDecl " + this.getName() + " :: Finished");
            return this;
        }
    }
            
    rewrite PTDecl {
        when ( this.isRewritten == false && dependenciesAreRewritten())
            // dependenciesAreRewritten() refers to this template's/package's
            // PTInstDecl, which again refer to templates. So in effect it
            // means all the templates this template depends on.
        to PTDecl {
            Log.d("JPT:Rewrite:PTDecl", "Rewriting PTDecl " + this.getName() + " :: Started");
            StringBuffer sb;
            sb = new StringBuffer();
            this.toString(sb);
            Log.d("JPT:Rewrite:PTDecl_before_rewrite", sb.toString());
            InstantiationRewriter x = new InstantiationRewriter(this);            
            x.run();
            this.isRewritten = true;            
            sb = new StringBuffer();
            this.toString(sb);
            Log.d("JPT:Rewrite:PTDecl_after_rewrite", sb.toString());
            Log.d("JPT:Rewrite:PTDecl", "Rewriting PTDecl " + this.getName() + " :: Finished");
            return this;
        }
    }

    rewrite PTClassAddsDecl {
        when (getPTDecl().isRewritten)
        to PTClassDecl {
            PTClassDecl newClassDecl = new PTClassDecl(getClassDecl());
            return newClassDecl;
        }
    }

    rewrite TemplateMethodAccessShort {
        when (hostIsRewritten())
        to TemplateMethodAccess {
            return Util.rewriteMethodAccess(this);
        }
    }

    public boolean TemplateMethodAccess.isRewritten = false;

    rewrite TemplateMethodAccess {
        when (hostIsRewritten() && !isRewritten)
        to TemplateMethodAccess {
            this.isRewritten = true;
            return Util.rewriteMethodAccess(this);
        }
    }

    rewrite TemplateConstructorAccessShort {
        when (hostIsRewritten())
        to TemplateConstructorAccess {
            return Util.rewriteConstructorAccess(this);
        }
    }            

    syn boolean PTMethodAccess.hostIsRewritten() = hasParentClass(PTClassDecl.class);
}
