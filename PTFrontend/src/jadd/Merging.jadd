aspect Merging {

    public void PTDecl.extendAddClassesWithInstantiatons() {
        HashMap<String,LinkedList<PTDummyClass>> nameAndDummies =
            getClassNamesWithDummyList();
        for (SimpleClass decl : getSimpleClassList()) {
            if (decl.isExtensible(nameAndDummies))
                decl.initiateExtension(nameAndDummies);
        }
    }

    public void PTDecl.copyImportDecls() {
	CompilationUnit ownCU = getCompilationUnit();
    	for (PTInstDecl instDecl : getPTInstDecls()) {
            PTTemplate originator = instDecl.getTemplate();
            if (originator == null)
                continue; // error caught elsewhere
            CompilationUnit cunit = originator.getCompilationUnit();
            if (cunit == ownCU) 
            	continue;
            for (ImportDecl id : cunit.getImportDeclList()) {
                if (!hasImportDecl(id.toString())) {
                    ImportDecl copy = (ImportDecl)id.copy();
                    ownCU.addImportDecl(copy);
                }
            }
        } 
    }

    public void SimpleClass.initiateExtension(HashMap<String,LinkedList<PTDummyClass>> nameAndDummies) {
        LinkedList<PTDummyClass> dummies = nameAndDummies.get(getID());
        if (dummies.size() > 1) {
            attemptMerging(dummies);
        } else {
            PTDummyClass instantiator = dummies.getFirst();
            attemptInstantiation(instantiator);                        
        }
    }
    
    public boolean SimpleClass.isExtensible(HashMap<String,LinkedList<PTDummyClass>> nameAndDummies) {
        if (nameAndDummies.containsKey(getID())) {
            if (isAddsClass()) {
                return true;
            } else {
                error("Class " + getID() + " has dual roles. It's both defined as an inpedendent class and as a template class instantiation.\n");
            }
        } else if (isAddsClass()) {
            error(getID() + " is an add class, template source class not found!\n");
        }
        return false;
    }

    public boolean SimpleClass.mergingIsPossible(HashSet<String> conflicts) {
        boolean addsResolvesConflicts = assertAddsResolvesConflict(conflicts);
        boolean addsHasOwnConstructor = assertAddsHasOwnConstructor();
        return addsResolvesConflicts && addsHasOwnConstructor;
    }

    public void SimpleClass.attemptMerging(LinkedList<PTDummyClass> dummies) {
        HashSet<String> conflicts = getConflicts(dummies);
        
        if (mergingIsPossible(conflicts)) {
            LinkedList<ClassDecl> instantiators = copyAndRenameForMerging(dummies,conflicts);
            for (ClassDecl instantiator : instantiators) 
                addDecls(instantiator);            
        }
    }

    public boolean SimpleClass.assertAddsResolvesConflict(HashSet<String> conflicts) {
        HashSet<String> addRefinements = getClassDecl().getDefinitionSignatures();
        for (String conflictingName : conflicts) {
            if (!addRefinements.contains(conflictingName)) {
                error(conflictingName + "is an unresolved conflict during merging.\n");
                return false;
            }
        }
        return true;
    }

    /* TODO empty constructors are auto-generated so this is a tautology
       maybe stop auto generation? not sure...
       aspect ImplicitConstructor -> LookupConstructor.jrag ... */
    public boolean SimpleClass.assertAddsHasOwnConstructor() {
        return getClassDecl().getConstructorDeclList().size() > 0;
    }

    // TOOD use google collections set operations
    public HashSet<String> SimpleClass.getConflicts(LinkedList<PTDummyClass> dummies) {
        HashSet<String>  collisions = new HashSet<String>();
        HashSet<String> allDefinitions = getClassDecl().getDefinitionSignatures();
        
        for (PTDummyClass dummy : dummies) {
            HashSet<String> instanceDecls = dummy.getDefinitionsRenamed();
            HashSet<String> localCollisions = new HashSet<String>(instanceDecls);
            localCollisions.retainAll(allDefinitions);
            instanceDecls.removeAll(localCollisions);
            allDefinitions.addAll(instanceDecls);
            collisions.addAll(localCollisions);
        }
        //System.out.println("collisions: " + collisions);
        return collisions;
        
    }

    //TODO abort on error
    public void SimpleClass.attemptInstantiation(PTDummyClass instantiator) {
        try {
            ClassDecl ext = instantiator.getInstantiatedClass();
            addDecls(ext);
        } catch (Exception e) { throw new RuntimeException("extendWithClass!: "+e); }
    }

    public ClassDecl PTDummyClass.getInstantiatedClass() {
        ClassDecl ext = getOriginator().fullCopy();
        ext.renameTypes(getInstDecl().getRenamedClasses());
        ext.renameDefinitions(getExplicitlyRenamedDefinitions());
        return ext;
    }


    public LinkedList<ClassDecl> SimpleClass.copyAndRenameForMerging(LinkedList<PTDummyClass> dummies,
                                                                     HashSet<String> conflicts) {
        LinkedList<ClassDecl> copiesToBeMerged = new LinkedList<ClassDecl>();
        for (PTDummyClass instantiator : dummies) {
            ClassDecl ext = instantiator.getInstantiatedClass();
            ext.resolveConflicts(instantiator,conflicts);
            ext.renameConstructors(instantiator);
            copiesToBeMerged.add(ext);
        }
        return copiesToBeMerged;
    }
    
    public void SimpleClass.addDecls(ClassDecl source) {
        ClassDecl target = getClassDecl();
        for (BodyDecl decl : source.getBodyDecls()) {
            if (decl.isNotEmptyConstructor())
                target.addBodyDecl(decl);            
        }
    }
    
    public void ClassDecl.resolveConflicts(PTDummyClass instantiator, HashSet<String> conflicts) {
        HashMap<String,String> resolvedConflict = instantiator.getRenamedConflictsMap(conflicts);
        //System.out.println("conflicts: " + conflicts);
        //System.out.println("resolved: " + resolvedConflict);
        renameDefinitions(resolvedConflict);
    }

 
    /*  TODO not very pretty */
    public void ClassDecl.renameConstructors(PTDummyClass instantiator) {
        int i = -1;
        for (BodyDecl decl : getBodyDeclList()) {
            i++;
            if (decl.isNotEmptyConstructor() && decl instanceof ConstructorDecl) { 
                ConstructorDecl cd = (ConstructorDecl) decl;
                try {
                   decl = cd.toMethodDecl(instantiator.getID(), instantiator.getOrgID(), getSuperClassName());
                   setBodyDecl(decl, i);
                   return;
                }
                catch (Exception e) {
                    cd.error("Could not rewrite constructor " + cd.dumpString() + " to method during class merging.\n");
                }
            }
        }
    }

    /* TODO
    *  Should have void returntype.
    *  cleanup!*/
    public MethodDecl ConstructorDecl.toMethodDecl(String returnType, String methodName, String orgSuperClass) {
        /* Rewrite a whole constructor declaration to a method.
           Will also rewrite constructor invocations to method invocations based on orgSuperClass.
        */
        String modifiedMethodName = String.format("super[%s]",methodName);
        MethodDecl md = new PTMergedConstructor(getModifiers(), new TypeAccess(returnType), modifiedMethodName , getParameterList(), new List(), new Opt(), methodName);
        md.setBlock(new Block(new List<Stmt>()));
        if (hasConstructorInvocation() && orgSuperClass != null) {
            // rewrite "super(x,y,z)" to "superA(x,y,z)" where A is the original superclass
            try {
                ExprStmt s = (ExprStmt) getConstructorInvocation();
                SuperConstructorAccess sa = (SuperConstructorAccess) s.getExpr();
                MethodAccess oldConstructorInvocationAsMethod = new MethodAccess("super[" + orgSuperClass+"]", sa.getArgList());
                oldConstructorInvocationAsMethod.IDstart = sa.IDstart;
                oldConstructorInvocationAsMethod.IDend = sa.IDend;
                md.getBlock().addStmt(new ExprStmt(oldConstructorInvocationAsMethod));
            } catch (Exception e) {
                getConstructorInvocation().error("Could not rewrite constructor invocation to method: " + e + "\n");
            }
        }
        for (Stmt s : getBlock().getStmtList()) {
            md.getBlock().addStmt(s);
        }
        md.getBlock().addStmt(new ReturnStmt(new ThisAccess()));
        md.IDstart = IDstart; // give the generated method the same location as the constructor
        md.IDend = IDend;
        return md;
    }

}
