/*
    Det er godt mulig dette lar seg gjøre med eksisterende løsninger,
    men jeg begynte å bli litt lei av å greppe rundt. Innspill er velkomne.
    - daniero
*/

import AST.List;
import java.util.HashSet;

aspect VirtualMethods {

	/**
	 *  Lookup all MethodDecls in this class and look up their origin to
	 *  see whether they are virtual (first appearance in the current
	 *  class hierarchy) or overrides.
	 *
	 *  To look up methods' "origin", this must be done before any
	 *  rewriting occurs, then the final test happens after the merge
	 *  is otherwise finished.
	 */
	 	
	public void ClassDecl.findVirtualMethods() {

		for (BodyDecl d: getBodyDecls()) { // the infamous getMethodDecls hack:
			if (d instanceof MethodDecl) {
				MethodDecl myMeth = (MethodDecl)d;
				ClassDecl c = superclass();

				wh: while (c != null) {
				/* Søker atm ALLE superklasser, helt opp til Object;
				   Bør/trenger vel bare søke opp til det øverste som er innen
				   vår package/template?  
				   F.eks bør vel toString() settes som "virtuell" hvis det er første
				   gang (øverst i klassehierarkiet) i denne P/T'en den blir deklarert,
				   selv om den også er definert i Object. */
					for (BodyDecl bd: c.getBodyDecls()) { 
						if (bd instanceof MethodDecl) { 
							MethodDecl superMeth = (MethodDecl)bd; 
							if (myMeth.sameSignature(superMeth))
								break wh;
						}
					}
					c = c.superclass();
				}
				
				if (c == null) // fant ingen supermetode
					myMeth.isVirtual = true;
				
			}
		}

	}

	public boolean MethodDecl.isVirtual; // first time defined [in this package/template]?

