/* Singleton class for generating identifiers (symbols), fashioned loosely after
   Lisp's (gensym).

   The string parameters are just for clarity and should never be disambiguating
   anything.

   The use of this class presents some problems if separate compilation is
   ever implemented.
   Using randomly-generated identifiers and hoping they don't collide seems
   unsatisfactory to me even though of course we can make these long enough
   that collisions are very unlikely. Barring this, the best option seems
   to be able to _recognize_ counters previously generated by gensym, and
   adjust them.
   E.g.:
        #:G1        #:G1                        #:G1     #:G4
        #:G2        #:G2                        #:G2     #:G5
        #:G3        #:G3        merge to =>     #:G3     #:G7
                    #:G4                                 #:G8

        Another option, similar but perhaps similar to implement, is to
        prepend a new identifier code, gensym'd for each separately
        compiled unit, to a _sequence_ of identifiers.

        #:G1        #:G1                        #:G1.1     #:G2.1
        #:G2        #:G2                        #:G1.2     #:G2.2
        #:G3        #:G3        merge to =>     #:G1.3     #:G2.3
                    #:G4                                   #:G2.4
        
        (Latter seems preferable.)

    This faffing about may move limits for the longest permissible identifiers
    if we keep the original name as part of the new one, but that's hardly
    a problem worth taking seriously (if it really did become a problem it could
    be solved by not doing that).

    We use dollar-signs in our patterns to avoid collisions with things users
    might use -- this is a Java convention.
*/

package javaworld;

import com.google.common.base.Joiner;
import java.util.Collection;
import java.util.LinkedList;

public class Gensym {
    private static final String prefix = "$$GS$";
    private static final String suffix = "$GS$$";
    static Gensym instance = null;
    private int nextInt;

    Gensym( int nextInt ) {
        this.nextInt = nextInt;
    }

    public static Gensym getInstance() {
        if( instance == null ) {
            instance = new Gensym(1);
        }
        return instance;
    }

    public int getInteger() {
        return nextInt++;
    }

    public Collection<Integer> getIntegerAsSequence() {
        java.util.LinkedList<Integer> x = new java.util.LinkedList<Integer>();
        x.add( getInteger() );
        return x;
    }


    private String createIdentifierFromComponents(Collection<Integer> numbers, String originalName) {
        StringBuilder sb = new StringBuilder();
        sb.append( prefix );
        sb.append( Joiner.on( "_" ).join( numbers ) );
        sb.append( suffix );
        String newName = originalName.replace('.', '$');
        sb.append(newName);
        return sb.toString();
    }

    public String newIdentifier() {
        return newIdentifier("");
    }

    public String newIdentifier(String originalName) {
        return createIdentifierFromComponents( getIntegerAsSequence(), originalName );
    }
}
