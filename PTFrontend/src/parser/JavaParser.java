// Generated from parser/JavaParser.all
package parser;
 import AST.*;
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JavaParser.beaver".
 */
public class JavaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short DOT = 1;
		static public final short SUPER = 2;
		static public final short IDENTIFIER = 3;
		static public final short LPAREN = 4;
		static public final short RPAREN = 5;
		static public final short LT = 6;
		static public final short LBRACE = 7;
		static public final short RBRACE = 8;
		static public final short LBRACK = 9;
		static public final short RBRACK = 10;
		static public final short SEMICOLON = 11;
		static public final short DO = 12;
		static public final short WHILE = 13;
		static public final short FOR = 14;
		static public final short VOID = 15;
		static public final short IMPORT = 16;
		static public final short STATIC = 17;
		static public final short MULT = 18;
		static public final short SIMPLERIGHTARROW = 19;
		static public final short THIS = 20;
		static public final short IF = 21;
		static public final short ELSE = 22;
		static public final short COLON = 23;
		static public final short NEW = 24;
		static public final short TEMPLATE = 25;
		static public final short PACKAGE = 26;
		static public final short INST = 27;
		static public final short WITH = 28;
		static public final short ASTERISK_PAR = 29;
		static public final short COMMA = 30;
		static public final short SWITCH = 31;
		static public final short BREAK = 32;
		static public final short CONTINUE = 33;
		static public final short SYNCHRONIZED = 34;
		static public final short CATCH = 35;
		static public final short ASSERT = 36;
		static public final short AT = 37;
		static public final short INTERFACE = 38;
		static public final short RIGHTARROW = 39;
		static public final short CLASS = 40;
		static public final short ADDS = 41;
		static public final short CASE = 42;
		static public final short DEFAULT = 43;
		static public final short RETURN = 44;
		static public final short THROW = 45;
		static public final short QUESTION = 46;
		static public final short EQ = 47;
		static public final short ENUM = 48;
		static public final short EXTENDS = 49;
		static public final short GT = 50;
		static public final short RSHIFT = 51;
		static public final short URSHIFT = 52;
		static public final short ELLIPSIS = 53;
		static public final short INTEGER_LITERAL = 54;
		static public final short LONG_LITERAL = 55;
		static public final short FLOATING_POINT_LITERAL = 56;
		static public final short DOUBLE_LITERAL = 57;
		static public final short BOOLEAN_LITERAL = 58;
		static public final short CHARACTER_LITERAL = 59;
		static public final short STRING_LITERAL = 60;
		static public final short NULL_LITERAL = 61;
		static public final short BOOLEAN = 62;
		static public final short BYTE = 63;
		static public final short SHORT = 64;
		static public final short INT = 65;
		static public final short LONG = 66;
		static public final short CHAR = 67;
		static public final short FLOAT = 68;
		static public final short DOUBLE = 69;
		static public final short PUBLIC = 70;
		static public final short PROTECTED = 71;
		static public final short PRIVATE = 72;
		static public final short ABSTRACT = 73;
		static public final short FINAL = 74;
		static public final short NATIVE = 75;
		static public final short TRANSIENT = 76;
		static public final short VOLATILE = 77;
		static public final short STRICTFP = 78;
		static public final short IMPLEMENTS = 79;
		static public final short THROWS = 80;
		static public final short TRY = 81;
		static public final short FINALLY = 82;
		static public final short PLUSPLUS = 83;
		static public final short MINUSMINUS = 84;
		static public final short PLUS = 85;
		static public final short MINUS = 86;
		static public final short COMP = 87;
		static public final short NOT = 88;
		static public final short DIV = 89;
		static public final short MOD = 90;
		static public final short LSHIFT = 91;
		static public final short LTEQ = 92;
		static public final short GTEQ = 93;
		static public final short INSTANCEOF = 94;
		static public final short EQEQ = 95;
		static public final short NOTEQ = 96;
		static public final short AND = 97;
		static public final short XOR = 98;
		static public final short OR = 99;
		static public final short ANDAND = 100;
		static public final short OROR = 101;
		static public final short MULTEQ = 102;
		static public final short DIVEQ = 103;
		static public final short MODEQ = 104;
		static public final short PLUSEQ = 105;
		static public final short MINUSEQ = 106;
		static public final short LSHIFTEQ = 107;
		static public final short RSHIFTEQ = 108;
		static public final short URSHIFTEQ = 109;
		static public final short ANDEQ = 110;
		static public final short XOREQ = 111;
		static public final short OREQ = 112;

		static public final String[] NAMES = {
			"EOF",
			"DOT",
			"SUPER",
			"IDENTIFIER",
			"LPAREN",
			"RPAREN",
			"LT",
			"LBRACE",
			"RBRACE",
			"LBRACK",
			"RBRACK",
			"SEMICOLON",
			"DO",
			"WHILE",
			"FOR",
			"VOID",
			"IMPORT",
			"STATIC",
			"MULT",
			"SIMPLERIGHTARROW",
			"THIS",
			"IF",
			"ELSE",
			"COLON",
			"NEW",
			"TEMPLATE",
			"PACKAGE",
			"INST",
			"WITH",
			"ASTERISK_PAR",
			"COMMA",
			"SWITCH",
			"BREAK",
			"CONTINUE",
			"SYNCHRONIZED",
			"CATCH",
			"ASSERT",
			"AT",
			"INTERFACE",
			"RIGHTARROW",
			"CLASS",
			"ADDS",
			"CASE",
			"DEFAULT",
			"RETURN",
			"THROW",
			"QUESTION",
			"EQ",
			"ENUM",
			"EXTENDS",
			"GT",
			"RSHIFT",
			"URSHIFT",
			"ELLIPSIS",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"BOOLEAN_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"BOOLEAN",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"CHAR",
			"FLOAT",
			"DOUBLE",
			"PUBLIC",
			"PROTECTED",
			"PRIVATE",
			"ABSTRACT",
			"FINAL",
			"NATIVE",
			"TRANSIENT",
			"VOLATILE",
			"STRICTFP",
			"IMPLEMENTS",
			"THROWS",
			"TRY",
			"FINALLY",
			"PLUSPLUS",
			"MINUSMINUS",
			"PLUS",
			"MINUS",
			"COMP",
			"NOT",
			"DIV",
			"MOD",
			"LSHIFT",
			"LTEQ",
			"GTEQ",
			"INSTANCEOF",
			"EQEQ",
			"NOTEQ",
			"AND",
			"XOR",
			"OR",
			"ANDAND",
			"OROR",
			"MULTEQ",
			"DIVEQ",
			"MODEQ",
			"PLUSEQ",
			"MINUSEQ",
			"LSHIFTEQ",
			"RSHIFTEQ",
			"URSHIFTEQ",
			"ANDEQ",
			"XOREQ",
			"OREQ"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjdGUS4yNRnv$PsLmkLtBqggSKyUWTb288A58KK7hlzeAzObTiW0MxeeAAlNViTBkYOa6" +
		"nDrJiTNVVtynEjYIRkoHNYFytUv$9pCvE#UupppnJDfiZcdi83USFqBxQltG#NK0NykLiP$" +
		"OpxyltuFruVzQIxS9sPRknNkm0DfhtvdqiIxj1kqcxMRk5ehmNzTJQqdXsE0sdVL36Kfh0B" +
		"evTP$trfxJrh1xrqDQowxKDr4NRfgrcIwchzgpsdFQyzeBsehPAUqbxMNj5UrLxJNjTUqDx" +
		"KtjBswYzhQtHsckxQgsf6z#REkjFKmdVdpz3nLIAccwcVMb7VdLwt3H3suKFviDe80q2Tos" +
		"QgxXdsjoyIuoRNq5rjVLKMt3phZ7kKBFKk6a8hQS7RMxZUdg0veAxhg9#Y3VbFwR7hLrAhr" +
		"8$key6KI$UY$r0BqdkMxJpgRtWfWuEztUq3Dnr13VkG76RTLBa7ar7qAasDzrAlLaZ$WpRo" +
		"ewdRzb4Dfi#qaUanyqVj1umUxBhgR$P4$BkXtONtFVpFschr9FnCMvz66q3zvwIktwCcx#Q" +
		"6hUWq#VQtEn0TZ0x5F9khUJz23sgFq73sUCkDmjLe2TRsLGsNSYRlmJkFgoruERhMNUsXvJ" +
		"tN8Vx4QadVQMUN6fpKpkpO$horizMFIQFNQ38owXZcjp3qDBzsF7iSg7VPXtMJt1hfThEMd" +
		"F1RVxiz5lK3EwsKjwZO$AcUrFZDdysVwRkIjxzQ05TH1VJ9RIG5j5YkbHVf$sZhzStY5I9V" +
		"sdUqH2$fL4zTdU#5sijMwADStskj3GZfAKvtj7y3Xcq12nDhBUoFZOdxgXXUkJiV1hazCfU" +
		"q8YUCTrdjgsvoR6H9#gDjVLyhxYs69gYxb$6DyLqd#RAVcfhZ$sv1xyoFMvzaBIE1Sf6RgL" +
		"lfUuNwNkmisIVFTsH#EFqfBPUsqzo3qkRUpoz0gickRM3utM8Xl7lqzRzZdRVPwrvB#jt6Y" +
		"2v$z2NehU2Mrlirtt#kEJUAnDDqHObvHwixvikDprDpz2pT1kjW9vqiELD6$KzQBRKy64Ez" +
		"rrq1$hi2t5wiYrbUN$DnYezkJsUc##iFvOUjnYJR7bR4o3ldjewmIti9i92ltTmkBVnKd2$" +
		"B6taZZ5kgsUAyhRrk1jr0dVQXCQ$Ge$fNH3sy13sa9hStY5yYfu0uMmfsKqEOO$g9gGVs6I" +
		"hEti0X4D0sCtgRji8gcjryxUzVg3n2wnRM11QtHt2RYaIccJHFPaGyjjOljvMZ2bwPzxBE9" +
		"HUZ16oXe9Gh#$QNssUjbvl9mYrmvoPNd7g8tXcX3IKvRFz9E4wtakCEv9mgoXHzdjt11af2" +
		"Dc#Wj1ix12UcA8CPOcP4BBsz1mzJy#oQzWy4FuAFHE4TL7YxN9KhkqGpjP$T7huj1YX$bEA" +
		"X1iXmSm8RsVtGeBtirjfDkQNTod2kUn1pCfyynrOcuCWmzQ2q5ZYsA2vgH7gBuM8PzPJOBl" +
		"OfQBlQe$oNd8Eh$goJUZsPRQ8BOxrPUqnXt1O6deuArDhemZ7G8R7gpcweuTylKDubIGSvf" +
		"#fyC#gMmy58MybEMz7N$wJloq8zJeOu#C8wLjjEbhvUFz8mxzEZP2NoVMA96J3jNVudgXfD" +
		"hNM$cRZsQNQZrpJFj6#P1tvBzeIUX4owwAz9zPBhBTs33i7$RYxDXuI#fb7UB5cOBtKJLkc" +
		"JM6BgKXV8LgUr#OD#CwsrUM$gZ5$4DkBxSq6ittO43QK3OiVtxJBjCkrAxGhjQkqgxLhjUk" +
		"qw#NilZ5THd$HFpQbiCRKcezYbsAySYXXWvVe9s1E3KfseTwUzJQkr3kRdRHPR34xpw7yLb" +
		"1YxDv6HLht62MTGLVHrNIDq7jj6UkRFYL6xHjuOto24grT5pFIijHQs#p4pfFQs5FR7Vfug" +
		"Lx6Nw7XeMAKO4jCVjBHaX1tpXQmHxI38FSDq0PXTSgqpVoGL4Q$TAZiNgADPfTIFqbLHzIj" +
		"VKHp#A7yC7uuFu8VIGSART2E1yifRB5#fNQcfEed#$53sgQgf#9Hut8G3GyX3opqEbvBZ2F" +
		"yQ6sgXsgsf3eFUWXY$JRPfXleU4LL3R8AjGgr2RMLjSL6DeJv2Ro7IwKTBQZibBodVe#maw" +
		"2QgwYsL3sLSOMiex7Mb0x5#a3q6K5raZ7H8olHffsqBjfy5aP$5f8wLTl0sqkgkjeNrK0rp" +
		"PfexMmrvntvAemFTsk7imPy0v$F7tQf#1FQ27fPtucFvyz2GdVHN3u#fbVyBks7Qj2hTxGb" +
		"nXWwIQ#hJq8B7c1Cr9y9xSBFHyrk2rv3B$CDUZx$2JFatMYf$Y9$7RBwK$R15dnQAbJyTzY" +
		"Z1DkXFwituqk5PTEdmPQtvfVJ9BhAOtyFq9P0HX$mQs5$P$EBMM#NIf$fMBQvjcNJfrDHA8" +
		"fUS8wqloFqnc8Sufj3jOMVlcNJ$kBxnIoRJKbR9UMtj9LlS2drtf3XiNo4f6pDDx3U#aHzi" +
		"lufvaeMqYbAlbvIrZKcKf7Q0GAb$fdUL#uDDT47yf5yJFgK#WTq3s$C$uodr8VASTsXD8xL" +
		"bcX$WWAK$7UiyNlhf#ZFKJ#gYxPzDKQfxoCfvqAAHLYFBjQVbxBydSxJcz1Md8$5NRLAdvB" +
		"lojlmnhf7bho3f7nOrEAHvIuOosRPb6OJlXwKfq43DkWdqn3qonZbyO9IFqjVhYXFaMDPNT" +
		"wPpwBbh5Y$Nf#j7va1vO7Q8b3Uw8wuh3vcGQsDep4Byb8U0ShJzGLYnDKxQuU0yZkwKpk0v" +
		"keVOsoAwMLTGOaUTQ9DoThA5j#2#rYadw5lHGzQHdTde9UB1ANTuchsyf2ad0TBDjVJUpQ8" +
		"tgFV8IWnSm8b$zCuMpk0Rq3gnnpAOLAM3#eMPYzphKyKfKaFyzz3TUWn$UzG0$tE3FJIq3$" +
		"XZKDbBgL98Ox#iIIqAsOihbx#WzxpX$6heBI#2TLdlKCbDDgmj8NQGlrRX$9JGHbgIAzH4M" +
		"rXUVIve6GH#f8LQeUo1eXhJ9zcC7jfofgXZxVmpB4#P#r0UHLhozgubAojjeHrO9ta7Aijw" +
		"ynwiwjPVzJUdsQpaJ5ADa1GiltPqUZZHx1Zs4cIyZXsCZk5dShEPVFPcUpiz2cD4rX$p0Hd" +
		"U$Jo8hOGbDTWZUQH9Ri2b5UovNA#MfVT2Cgsx6QsWjr3mzZ33kKJal8f#Xoo$99zRbmdUy#" +
		"dx2lQObnbN6DSpROPrsOmNzsY5O3oKvTIguKwMlEjMbtwqgNKXi8IDT262KfjNsq4PjKZjG" +
		"dQ$jeuRIBknjTxjCcumo9jcZPRcsdtSMqEt87QuTfHsX7Q2HdqdkDGScFjH4#BrzLE1kKFg" +
		"Fiq3#LPe3m3KXIKPyFlhPshNQ1TJETejs9iZb7EjksbTZiexz3kqUuMbDgzqDwdyFckzZvr" +
		"q3xCWF9ZxLDGVkwHvLVQDw3SfdsdVU#Xn0f5#qdxJLB#eVsE5dzACv6EEEEwC$Q412KFytm" +
		"gueMQoKkaLQzh7CaR8MqJk9ruimpiPGlaRCnRUcGvbxU6LH$EEv774Y6y15TsbvI7yj6mH4" +
		"EC0ynx#N0#rHZdK4wMb3Cn#XIPf$Avo05AynIhcRMtjPSro1h8ZxK6f4zfdcxr0UKyZxqya" +
		"OknPp#h7p$5OozFqvPOhVWPqbwUnyy2vJbM2tuHly0yZIzqA1TBoiluTP3b3VmMVgEKvQty" +
		"TduFNyRlv7Vm#$Zz6LYY9$YZe7pCG$aaVngK8$bA$fo7yWLOzHVvQacvbgzZlM71NuPxbt$" +
		"8FtOetvUKM$WNeFoKVyL$avGR#3VyPwJzMo$Gy$J23AnwaLuF8sJKfTHBzGQWV5HlP1pZKf" +
		"fNOuJSMMykHyYMUXb6o5trSp6QT3IdwZsTSNmtEVRqqljWxEcd3z3xsvJwNleGVR2#lpv67" +
		"wTFpO1oXZu7bcYOX$8GlGYKZ#k7weTxnl4oK1wb7oqfZv4pDrW7$IIuCtLdvQnV82alr2#6" +
		"lNnClrg$GOwGr#WtwTVfDuDs6MBloi1UFgO$05dUvw5y2DQkjVwalX8soQL4YuDebQHyMNy" +
		"5bA$hxo1cixv9$z2Xt2mfFzBHuleN#kVwbvBoA$rh$Hlz1$nzhs$JVyv0bh$eluFo3m$bdo" +
		"56hKEQlfc6kfIXaBOaL8kaLG$Lew4Onnk5seLQXpg6D2B7NfAqb#8eafyahNhSaO4iHKcDy" +
		"H6u2q46sv6LijrPJ$yAY7wcNvXEVxAPR1QRouv4pKUnCP9W86l5TfAXEje3QizfitP$Ugih" +
		"tFUIs3rX9Uexz7FiKh6w4cTYTKLONSa3QpwoLrVQffHst4IU09beA#0UJ9VPFMncLaz#Niz" +
		"kONV8q5AK#hIllLRg5yMOyRabfPtM#SZtgSh$Cbl7DaWvN8ByjsbtPiBCNc2h13DxXZt7rh" +
		"1NsUliJRQHlSCsiVVPX#mZjWNbjq72OKJ6MLuvO#J$8hNdA6bHJVH9Cluv72K#KVItFgX#g" +
		"7QgH8eAgJYl1gfvQL9H71NnQPbHLQjjA4cnx0#3odO4ifa#mETRufaMlL69EnWcQj7V5RNG" +
		"PzfAQHk8xgb4YVqIkD#CaqbYIpg7TaacDTEFsYDUsuCohaCPtTIt88g4dcd5MZIn3AsFrbV" +
		"RnsErlbM1TnoY#uBjPNNgI3Rg7$lErZ$j2IcFcFw9umt4TDCwQYsr7RL6MdsjZbQYHIZ9mR" +
		"xK1cW3jTxi6$Qr7HCRzLWjlMcIiIazPfCiNvzvCwxFI6Rs2$kD$S7#OlymWraQqxWMqiBqU" +
		"cLhrpkuhQ6V4EknUcjHkzxPhftju9M86FLyv#UBFgDtKlgtJCcjY1Ka4UdxrMvbRERKzLIa" +
		"rzaoC3V9KhRRm3OgIzdk1jknMSfs7zXEorAsXy1sHjQn3PDiZu8jO6pBc6rUEMpYI3h2nX#" +
		"ibhGjIwhSwWQo9R6wIGvpcsIxeR9ivZPpMyLi8bNYNrAs7mMRDhpIR3#QFwR0zcFGNo2Ocf" +
		"k3hIhjs#bLecykszWiPfjKXMmJgvXjHjQnAKAmpQtqt2cIakrrZnIb1xOZAyrsS1Mo3NE3O" +
		"AkfiJujNLDi9sKns#bPp7PEzhBnwxEOxUOiPbkHnMptPZ7R8rd5vZd0zbGDiSd3#QQg2A$7" +
		"IlyzErv$Av3j#Mfb6#PPowJpdMQRJJvVKCyln3U6xViJtwr$qxrBVQEuIpwRpx2lyudfjX4" +
		"$k2fbmEgnElBDFZ9x2XcmfROCk7YQCPpEfNtfRBiULVj1CGwaB#VGn4xMU9egql59D9acL4" +
		"$ByUcovQPugBqKtz9mFi2jDSrzpnhe1tneG0lNIL$$dBm1#fVOotpwL#x1XclFiAx6TEHxI" +
		"EKuMEnxuaf79qqNvVUMvGViUweTEwbFseqnVVBkUrRqB3DsLxR#sNUb3l4iyrVwdH7JjEME" +
		"7Cxqo6H1WeHZxLpf5kRJAspXUZMr$#BhhG5zD$xGJ$MThX6zLHvh8Lr7WzXXGjRyx2gyYzL" +
		"9xo9QwLfMfI2hvZNI8dlMI2qtsRQ2FPdsivB7L6dZdNO$eBgij68UgvW$Ir35wsa$6aFZ0f" +
		"JKETYTAZ2YHkJwOqtKeYseaLe#g95QFgkHMdwjaLgi6XdxysgabeOrKalt6gbbjngfPKgDr" +
		"79SZTHoQetKSc7rri9gLtFvrMnLsE$LNFwVrLp#tzLS$h$LNBvPlULhLR2IABTyhPhBrwkv" +
		"$6eOwTGtwKNvhRLy4Ulv9hqwv1iU55kPnWxxMxQyllYMBVcEJBvb6vTwE3yALE9RjgtbobH" +
		"IyPFvwLugVanDKqbPnL5jVrdbg79K$t$wO8ugHrNpLEBTYlAfj6i4bTgZtIrpgg1tAwhhRH" +
		"C7QpFxeXhB$gcgosR3QPXeBTgigLrPOxoIRyVOUp3#$NJ$ORy74$i6RF8ZWpVhOcHIXxA9p" +
		"CbQvNf47rTn#tvInULz7$VC9FttVTG#Fk#Lv4dGM$ee15jHCtnwlgl39mZBGiDOLvdo8UrX" +
		"Nnjwd$qqfvQqYrSZj2TzUX7JYBYdFpXsIaqZH1fzGlmpBKSZrBCVn2$NkwhuHjIOcb1JsZc" +
		"94WhhbdbBrVEs55LTcrUPDcg5VccxBKaRwUsaBMdxTajAQMiN9Ns26AWtQOrSKc#SCrzB1c" +
		"gBU#pa2ITBfxH5dv38J$QJwmrkEg4tCbs0tkZ$LfNUw5qyRRIvQjfQgvqe0L#$VRp2raxoh" +
		"5Zqs$8iH1gjxM$f#DRsyUj$9RQq$Xi5VXSXrPRcxTnKr92z9Qs7sz9Lq0vKDNEGWESqwPUY" +
		"1JnlJgSK#ggI5EzLBh$Mq6UjvDfHlpTOV$MbqDyCQwFlAjJVvDRBfx#PtorzKobPZQjKxhS" +
		"hbVlTokJM0jw1IYFt3buBvxSCISSpUVX7CMsPlbfO1ZgExFSjJl5ygyJEMx65owS2AfHfRQ" +
		"OyzKqPZuOuJ6EJpfz7qVxsysyrMnAwaSJYfMnrOy$r3vFFzK#ZexnC$1BPVxfHQsEkJDN2p" +
		"gIBDuntfQ3ZP8ySxRVn3zAdaFY5Wh7UPFfXAZ3VUr$ggFYtKbokEKcv$2tkiHP#Bhyk2AxO" +
		"tCRvniDDgiLJM8EaCxUncOp3w0fv6gGBNltCj2zCo8Y9gfNfe9IOWdNRo#IsgdqSw31s9Bl" +
		"FshJ7q8HAq1vI8UsKb2LuR1L9y9KiRDNNif3fZUnZqdRAGgOAVx5gEp2roqAc3ZLikMwibE" +
		"Lwh4BQA#8b64WhcChPsqluVlvgTS6UCSLzUpWb2QePazEgUTNNglHzXkDsTMhQf2nacfE5J" +
		"6kpa6bz5ZAzb7rCMgiiP2hBGgOsMSSavxjPnlHYkan#DY#JSPIwKbLigxENJUkSnMnTqsMh" +
		"RZsZdrJUR6BwBGkP$iX2fh#paEdVx6DYB0kPU1OozKYHAVbJolZdcS4hnmhUqzJ3yjaRSOj" +
		"V8l$7ZzolrLeWRVo#Q9BTOfrqJUTn#xM#G#tNodMfFCwqzqHrdLBO5xLRGWybrXzh2Mx4hI" +
		"mzEsgUmwt$S9gWtov3nxgNqz4ERlhMkzwME0jKOxdyVal0UbVjLlFOCyWZ0qazHnfKXocce" +
		"nAfgaXdfwKlgGhs1IhFD2CBcQxDGgQdiv3fsInaUZxxcBHKnugQPDej2vbwPI5JlonasZCB" +
		"cVRAGgR1rSxa71NiWYSSwNzl89INBfDzX30FrDUeS3YK7ug4almcRat8AUbH#Uyo7AUOBbT" +
		"FxAkhxQv8kUsME7BAiEqIZYkhuZiVYccbAoTj3ws$DaZRkp9jbx36MPSw4plSPdA#jnid9x" +
		"r75J6b8QUAcEnVaiak9lsgB6JAmhRBIZabMtEg8$NVGTkkTZp9aHgJ$hxBf6zCbodHZkklo" +
		"GjX$OqCcGA#krTP9dMXokO5$njCwHx$NHtFCUMOSamvfXnJZYd7b6FACUMOSamvfXnJZYd7" +
		"b6FACUMOSamvfXnJZYd7b6FACUMOSamvfXnJZYd7b6FACLNqdyigPFAzIUJBMkwljfNtIwh" +
		"UUrF$OKySOodPxsTw$f#L$0zxGMyIJLV#8QdVco5#jqgzlsA$IMJ$Bg$$tlJDNbxlx$BgR$" +
		"ju3tPuFGTFyb#u4j$zqhRMZ7vmt##BLNJa#b6EANkOAldTwsfXoaOvvPYoV4pr$ez8xx6Tn" +
		"jGattBTMttBTKG6ydQ#vMeVeRouTxZbV$3MRoKoZf0XzIwzU0FR6OL5lfPmJLLOlP73nwNm" +
		"1hOjYNEHgxddOeLlO7ku3Y#Fot$miUhxwW5SCVdhXvMZMnLpgQCAtw4FJfdoE$GLfjn1hot" +
		"lUv7$Lkrtw9E#cpDS$Dy4OxHCkLY$J7SqYdMKxz2JqcFn3fCjnuJVcHLls#iXoH7u7W0tzB" +
		"TI$8xzGYBxzrYv#xlbGexs4Vz$LkFcfRhupRZfChT99zfn$7DvvUvuOlvHd7xPyzBJd3VSv" +
		"Q5Tet#8tFdy9xs4r5kfzdi0yCMxQ#ez0BtOoNATd9UcglTBQ7v8ITb#3o21A$uumUQIES15" +
		"5EDofD2YdDmfSed3E5wMThb76kLnaOUhGZjHAQxZAilbrrBziD3EAbdYEmQfsWcFzMNrXFL" +
		"br$E1V90yNnfVA5iPGbfzlRuX$afefqJhwydtgV9VPklOXb1xRzzrIf2$SHyu1l4uYXVOAk" +
		"a$mvvZQzYhx7Ns9jl8tc6RsFliG$OHs#AaJCi69lnwXLkZbqfJLEAGbiqOcPvbgzYYk2H#o" +
		"sPCjKdaJ4JAHrkIRFuHiu7#TMYS95EmRVf2DM85$JPpnzWOaMp4qci5qmKTgSh5#Y0WRqUA" +
		"nEGIAfB$Uyb3ehyKwk1FNtv$Jvdauu1VPgc898wyYaW#oWuIyP#C0ad8gxNLFfCVbYIhM1c" +
		"cQdFL61LdSrkKyrvN1ZPN7CuxwFQHmExQN8STQOoneSQ9DbUxHgJn$aynTRr9$Ft9D7fQx2" +
		"cDTOQO1GNC6FtiYL8NN0vxqXaZs7kAD7nEcdBF9lQDdemvzXfZrtUiDlOWidJOanw1$zsjE" +
		"jXzgwnKRQIsp97oU9ggzWFidOeaRxscm6LRHySAnbb7hBAyalLQHtUL9IKRGeid$aB7T9Lt" +
		"X6zUjBQg9Kj9LisfIxQYLJDlo$t$socrqIS96t#JBzAMyDUs6riv$tSCR5YDWwsy$qsM2b6" +
		"wr1GiAqdqYIGgFysNCaqDa#cxLqocxxbToFPEWMpqTY4xDWMoQwkIBBLV2q2jj$Z80WwakL" +
		"#cAMTMQRsVc0zsCn9RoTkh0nM$e$Xb8tjru5t91wqEGgMshnzMRj$q7KdiKcgjcKejvUsvn" +
		"$uhPtD$BSOKR#lHLFCSAO$uFVU88oF8gxnrjIql$aO5EqfZayf3ZMJcsO7N8zQ7M0MTeDhD" +
		"tNEFk3MuxPbiLIVYzSDIt$4AuhGs9#7RbCYnNVZU2#OppymEFlEiOBuWZcH7nZkN5VFDewF" +
		"f63gMZgFZwGGwaKwYa#aKEfLEe$bqEfr1Pz9Pw6VdeB#TXzv6T0rTIzT1TrTYd5zAULY9Nw" +
		"RAk9AkmbepTZr2h#0wevlf5iGkfrlfDheTiNVGdNGNtKttqBrq7zrF3z23z10zJ8$Ge$GOF" +
		"KvFq9Fq57MXhjIDdgNdw7dwYNw6tLjD77RJhgcGNawJcz4aQaDj9Ur2i4VytAo#m$qNQbaA" +
		"Td2pdMFSh5wAt8o#fUyKTuYsePxL3lKVR9#qkT#WDz7t1QkGTmTwJuP$HIXVohlGmotalLB" +
		"AE#p8kpH3UNDmpq7hviduEHd8EumoT3O49Ip47TZopaFi9CdTnSDT1zobaZlVaNT1Yjo2hh" +
		"FYdanJQAf7tg8bqkMUXD5Wec1bmwIUCCcz5csvGd97WlI4tgsKl6CbCjHXqovFcvkZvX6gD" +
		"ov4s98XMoA2kwDJYwXvAIGjkBkaBUy3Q3HqpkQsQ0$gH$rfJnf00saGxKNlW$j3sanpwK0w" +
		"Y0wcG#XGEemEfoFeI3egRGtoMnfRWpWPk29wx9GuIyFb7ULLMlF3SPmliuPfaWlE69jeYwM" +
		"ExhDu6ydsmbN3tnQeBJNorIWffliHUHSsf$svCWCTiYLiwz0afKs5L1BFpQQp6U1UBRbvsj" +
		"nTf5MpkRzAq26UaUxRcix0pM4TRHjP0ga8xXLnkh#w4fhoQb9kbZutsvMLiTPegPLIJsnvX" +
		"nrkxd2$8ZISxH6d9tLIvfv6qnNtpmdSBJ8Qasnv5u8xfCOaOJSBuyRIEhH$pBQxOsdAyhQf" +
		"RExq2KibLNuGeSUsT8PqX6qHaYsjGS8nM1U491MJX8MEZIYCQ$jVfGMPbo6XiDUTCoBKm90" +
		"lnnIxbMSuXFCIPdgDd15yTTg4tX4yFS9v89md2Ty7eHXt1E4aMQ8WNEqGbaf25YV3LEUYap" +
		"mZH9fZcEhX8R0iXCGYgeTFKXQrr2F3kauFTotJZYaIXY71I6Q4O1iXFoEobMt2249rukOxT" +
		"M17OpAaj6Ke$XzyVaQ4mdQjb7rNzENO75wSrudhow$Hwm5zcQUXXoiojZOseGx2F6LjN3rS" +
		"6qSOFrDvjzhrK11o#SdaI6CJleSI8t64URW7iQhpZpIf4dRtZEp2VkYe8mBjp4TPAs57YgY" +
		"OeXZVDb5js9ELL8$gorbw8wHSWLgtIGdjH3jJCsfEVr1BsaN6b65c9bg#7RN7U6NV#zzg3E" +
		"f1FMatsfrwKM$gGtqJnhUzQJ3jGqDeA0sZuRGlxIVlVHJuX6sqAOKr5fGhCLwvb1oK75I2S" +
		"WMkDeBU5q9wWiXoAFCaPHwqiGmkHjbPpIk5tk$26cH0ARw3CWgVWZAzrXQpVw6DmearJ1Yp" +
		"Uxi4MsBsfqs8EmTTIDxJShILQErmMgDVUhra7jm8IVMUbFf7L41Rw1Fwb3wZpn4MsY1OXDk" +
		"cg4P8gZ#gXKfywsYbohCGuqYX74S#WhrsgI8EbI3U9jjqELgysgZORcntralM5XlPR5aLUg" +
		"Zc2IgLiY6eX9sCjM3ro8fa7SALWaeGsLHX3rKiLaVPUL9IOaR0gr6lnDn9kExeBmjbVsOq4" +
		"bIwXqgJQmGThXuaL2fTJAzMLmjL8Mn72BKKeXunyeUXPKr05V5GDSVraR0ThU2NWV4LIHMM" +
		"L9rIf2h5NwBj#1bhLjkoRP8pjdpPsrtBTZleHiAc2SiM0LKZ3zLFZcMBAClsD#WOpbP8osP" +
		"WpIeisrgK9$oqBHihPJivbiscdAGe9u7AfLm1oaAiZWLb65SQiQ4uByIgMSDPZ7Ajf0pZhq" +
		"nPDa5PYdX1rvRUbVMbJobcfQDGQYAbADUbH4kp4QXDK9RYkXZBX8q3CHlhKBuhAIFuAyDzh" +
		"K1RsvGhG3X9neXTZFH7YLVnDmgrkvIlAafHfalv3sIvoQ5S2yeGP3XIxd25uoXNmhSfTKaP" +
		"bhMibBH$Ln6b9dTpyy4QJobM7OAo49#2SYK#8wBL7SgmtUAiYQ8iavGx24x4YJOGzv0fPJY" +
		"GihE7SgJiFPiavLf96GPd8yHn$CKekQHy5xfQXjpCfcJTPO#jBUrH8QIPlbxsOED0oJoKfT" +
		"1LGLc8CvTIr58gBLvzz3KElZhmImKZ6#zGpfAKTQWZ#6QZr9bIbZfcPsB7ao5EHvhqPIbM4" +
		"gCmdhkKCr6Ue2oZhpoKPQ3y2lK8Id6baUm9CsHFqHtA0aaPGZbbSeRA9MM82fYOS$#2aBYM" +
		"FgKkAICUIb6Me0pxPAbBQxv2MIBHrcLW#Wen72v6kK9Ihi2Tbk4E6YATe9m5VxOa3Ccuz2b" +
		"dusyKod4fPw4EGJaJzVZdgpDmLL26P8lh6Dr4lRf7ByDAbi9UpfFNxJwkoplZClNgZ5ey34" +
		"hTGnbMiXIhT9TojPHbM5BgqbuAkUHBQnE96tl4EhHCKB4MahAZj0uTaLwNetxwb0sGSnHok" +
		"fIY9BltXE9QNCJ85cVxIRsqxsWvKiGeTINBGb0Mof84PQ7y2yknV3bYCvNbSWzbH5aYBcrX" +
		"Z382oeYqbB4LIaCfpOQIAKRPK59oEVOqbBwWR8WK3TIVJfciK4JEKIZ7fMoWMho1b4MCCWJ" +
		"A1evU5eAoKAPiA6DZb24rZkkonKDAbaorKA6AIvzo1VADGix45WybK1RwABbjBM7ZUHobxb" +
		"1kafGZfRtWidqAMRCCA4N#KSZlKd8bIrkRFBCDIISekUmz$p2IDUTxA6DwkHQKTe#sATq#l" +
		"ZOZUxa9VwEGqqifPbxvk6UllGo3yX$4s7ryfEpZOWOiN7wC4jo2Cb#E2RQSxR779XufIJTb" +
		"GCbbY$ijKLYjxyCUofMW3AjT25kM#T9lIYinQiTasLJr7Z7sS8pVkqfApcPAKivwuBDknfH" +
		"rVRAqfTdKPo$pfLxQicIuqaYUoRIMimk142Wj75HcoKDGMd57#fGoroYuz7SX5iXlviXl12" +
		"B$8beioxgShg0bCdIri#Tq0zsONjd8NTkvfuLnznWhjRaym#hA8vFbS6cihcIU09dGxt1$f" +
		"iliOPJCnEId3Zt8aw68PR4MldHrq4SKCpvJOcQDaRA3oY$te4I8jOGRnVRFX5civmMpt4#Q" +
		"fDPOOXTW1kOVip0tcOEoHoC5Xmlvv9pgtcjwcjN1Aybu7ROIdqhpkDQl0Qe0Yly4bPCsJQt" +
		"B7jlWBTl#9d9ysSuzecnytYJNoyigKGkNttTkhMgHjW6kSoLA717FZNM9JoQ9BUcsCujaLZ" +
		"Cxm6TxqYmZthg1Oryd9WDxMLCwKfFwnvhQ#gVaeVHFNby6URLXRLaxrfvrO1rP9zQPTR6I7" +
		"AmVwy$sP0FOG3P8IJZ6sx6oibRVtXVZlLSUl$ZxZCqS$3sVJFNFhPsHH$DvhCTY9YHQez2L" +
		"c4SYZVqIebBHPyIe9yzsKVxJz4mIYLQQELw371A$n5AkHQONjO0vnvPZ#$$C9cUMLSucvaR" +
		"9sEHdqX4s$g2EjcsfQgkRH6w1LZV7LdLipjmy2$Kjn$Q$nnOZh9A#q2eLs#kfDKNfPHjRh3" +
		"shlatBOqjFrt9iEROSMuxjVutDnrbZR2fExNJ8y5AucrNyhJNFXb4n$RMCsbUFxKMePm6Nq" +
		"cMgNF46HQ5xbwosVPTqYxf#MxfjHCzMfGo8qTNYQHL2UL864RTz$FMesas7exGyIbOd9WNg" +
		"mXh9RoLNIyknlINrcg1T95pDgyo#PqtsWyfG#xGZGF#2UfchV#Mr8gxRpp9328LLpBDYtnD" +
		"#YPEcdl8RIVg0VK$rB3DEdxpxdXKzoupTbQr$zbsfMiLgKNn7THoDZzsLhNzEk562XAUgl9" +
		"LkOUXVLUwCLDt#Iq3VJMZRftrdFfs9rw3qUr8vgwmrrISh#ZK3MMt$7R7jKajWkrVd#9h4I" +
		"YFcBTf8RzCxmNggqdoX$6#oNQwvMdArv6h9rPAhfGg$rP4hFrT#hlnS#KxvQcKgvfLXPOMS" +
		"RzawjTUZ#jBthG2ztxArV4SctxADIwsftHJrvb6EAaULeyfHvQXoLDk7IhnRKJuL$a3bVTy" +
		"aCwh0TokgwMqJXweQlYrSdMKxhINdHJAkKFabbdeFnh#V7jSAwZsOn2lfjLR06qmnCgb3sK" +
		"JcvAoEjvR#M#Mb$rnIxUvY5btEao3noq3ulDtJIhUvbWMXCENxsj1hxrwW5scLLoFyJmQTR" +
		"sidF96WZrFJ29dcj$Wd4ev6g6S$EBk5AKfMn8fPb9MmMi4wo7Q8vqcdfLZlkESPLTRcrLPI" +
		"IYsf$4QktiZltQUXD#cCNBRUE6U#bWpI5a$EZptX9EaSlVyjc5zeYvjEw8ryKX#WD#upnIh" +
		"McwfgwyH#bLPh9tjMBFfjUHOYzTRsjtHyQ$lvsOJ4bcQpojE7r5ewbehbg#UPJajNKJly3v" +
		"MotVCdwA$pRTyu$QKIw6$cEqiLpKIIMg$a#flstUPoPvBRgo7#afACPohiimsqY$YscVnMo" +
		"Qsk$KlFmhcsJUr7Rh3aDsLy6gAOQ4so#RFx$5kjmZuePsHBrUh6B9xz#zew2$cOP8#oVrjA" +
		"XXBc#l47yypi$M$ZY#zpUAvrKkdxMWdFzLFv7OMAkSgPs$YvVBeWkBnp6nbIBPxA6YIjkOt" +
		"wrfGjcI1Ty8t0rMR1WfZKsNPb2jPj7vFJgkfQWHCgSMQdzUmMhDOnmAFRvKjGzDd$twsQOy" +
		"en$Qyp$PSjLo1jWENooRxSx#TxVuz4dgSYGJLZSiR83TNPgfcDszMhQJcc75EEASUKdKmox" +
		"t#SAOxDo#HPJ#RO$ajirQzdAc#EASUKOyenfS1KpbEfkEUPLl3Rj2c#fqct4dV#NvVwJw4g" +
		"dzeNJRfRR3#T3$ZrL2T5fo0IIpvxI$LR8$HRm5D8rHACnprPzkqMEnJ#DwPtbA4FFDVJq0x" +
		"MnxlUzRO4qwc4rh3XCZvXlHlRhMQJrVa7LWL7wbICsKnik#kiZx$SVO4SKuufnvHZoZ7bcF" +
		"u$CddofV4hDQan1Nrl83qc5VCbtDSgl9M#fn$enqoPAY#dP4TLV9T1oIasEwscjgCrgRQT$" +
		"8v6fTek$c3wzfHJiYF94wyKv9GgarhZP9K#vPXoJ3N9bBgLsfvsFDcH6XChT9bOxBjSbR3Z" +
		"hAiCtyfwPiPK#J4u6#S5sSYKxl7VrV4SKuufnvHZoZ7bc79CEQOSKuufnvHZoZ7bc79CEQO" +
		"SKuufnvHZoZ7bc79CEQOSKuufnvHZoZ7bc79CEQOSKtc$$9WAKz3lX0OmfVTzO#$xH0kTyi" +
		"J$CGkyD#$lNibVKWruayZzVrPft5k#U9F8Jck$IKH1twDgwkFr$2wl$pUnMAiOhu$Bj0AFn" +
		"7U$MDsQqGysE9We2MUk7#MOSamvfXoJMyx$t9WQ$2rN#aBzBbKQOwgJBkvNYcc3$ntks2zJ" +
		"mfNxYvb1R#IGMV4RsFR1wiA5FTSgVWCxHIx$mGQhx$86SCNaJvtA#RvwXLofoZ$rT#YJl8c" +
		"I#ZlqAQUCkrVxVPzaxmXuVeiWxZVDIvnVkAzdSwetu1D#PnPn7zDlqW$KQyP1dzftxBcbth" +
		"2ttw6FoL65ud#FDMvUoiH$A97pKjOdreTS$OeZZjClUrxAd3VSLQhcJBFrYusCwHUBQMWdy" +
		"V$GLTmqfvnTnBmqTRrdVUtt092pPn1N$C76s5poiyB#c73NANB9jBx#ACFbSAaK$mckkDzH" +
		"xbJEsoefsWblpo4chQ$uRK2fTHH9ABKElO$F3sbpmfLotuUC$LuXTQ6kr8t#zV#EY7tOrZT" +
		"e36Brukg2RPB#19f8asWoJQ6fD8scqmoQIRDeDirnKgPb0#D$lS9JetVrDiccaf$sVp6OdP" +
		"vbI#7D3uSaphBbsoHor9TIeTh9vX#E3VIjG#FIf63RO0FjrWhwRUOIPun8CcAnvi5qWSGfo" +
		"eKe86#9w5UsNAYM$6KMxxivZQb9NFfo#tlg907z$VyvYHMmOn6ljObwaiwH0WbFabFCRBBA" +
		"vihp3RvI4jXTc#liEedPHYXmnjjSjdD2RwT$4#$FE#DDXJsriKvOzS3VNFAn1yiznfvyneW" +
		"qIsNRUFuxJ8uznxvzsGF9qc1FVWJzTxVgO8#R2QLk8sF$jKYiieIKRrRIJ$RMQyLSzghFdJ" +
		"LlY2jXZLUoFkle$ZSFI9Q#15t2ZDJT$VVDY$wjQia6wxELpem$nLLpwfBro2pnL#FMqNh8x" +
		"ANjnLRk$nq36pvVAZTD2aJfKgkqGNP94QMI9aUM8mj8azAl1SIJ1HqEMJcpoi0Lq$jK65l9" +
		"swi35IzdbVRgmBkI3zonZDdDJXNjT7lg3RPBARLcAhMaOYKWC$$$tCltjnvMKxMjn3rtP#T" +
		"6oAkyTRKjBreNBo$dcltRdskIoICsaebs2x2LXJB#2yNXxBa7xombMzN9$uhSAVKThq3ESl" +
		"ZYEN9ygVC5SIGxCjsvh9YFADJf31B7b4VnqH3#FqHJ#nFDwIdYWnoE$OdqvrJuBENVQVkTQ" +
		"XEnFLHuIfBy8vALdPYMpRJzmXu8$wBoRtIl5rwGc4UBslwqvkfyDEwpjihxcOexq$RvZYXt" +
		"5$XxkVdvyJ0ERU4lWzk0UtqMRbqmNmXbrqRwq4J5#xAAloanRUG5f3q2TL#cqho8y#SHE9e" +
		"ext3ujn65ToNAxs5Vp##Z$0NA$vUemGXLpnf$sU6NKDOJu1saqbw9vZnVrRiOuRVL$RyHb#" +
		"zaeZetehmBLBwFY0f6Wd4O$AU2xZcP8sey0VdsgpXTmGT8UpjOPy7$3Jxkky1Ir$vMidbGt" +
		"UULjb#ul$AdAd#PMrxXSa$uMhZ7uLwqptNeUE6hxlKc0o5hr5$ukhh#4C9lUAvVwYdhERXL" +
		"AlmU75Zrkl1$Lt4ReUCd9DvVkuWg#q3Rxp0zCGtTGzGREbruC$mpuLyF7srOU2jHd$hmxuG" +
		"$3RAv7FuTa4C4$Y$8jvceRr#KFHV##OZl23#kJVTeglmvdhZxbF#NOhlUlTPleF8lSUEAGc" +
		"Y3IIgSX$k4dXQ5xVDG56dVjSDr8Ul#pPGyxX8t2tztf2q6MxxANqJK6HQvg5MY70hlHNmBb" +
		"74e$9PnrzwqVMqyhjLou$MJSDvGbRqdt8xkjVwFeDw5yAtukkphR0lIzuSR0AVkk$DCXFTH" +
		"TNuJbCzVHkXOCCrGzGz1$hlXZunBynFHdhZ6m$3HXgmTVBHTk3tH0FHnZhOUCCzEE#0fDv#" +
		"#0z50o3wCzWz$ZV08rFK0$6jG9cJQv6DLBsnm8yWj11tYi4z51y2D0SllyCVRQHgfyel6mS" +
		"5ESTZceib4NSJzJx6lTRaGOTMdYcR0mHxmvrqUGXr5i6z59wAk3rGUw7tHsN3d#E#vw08uo" +
		"BvhAVn5S9SgMK3N1ogxMsibhX#4QrVOvrq5kxA7axUez2R6eLrKcSVOVZVeVnv3$64g3SQf" +
		"AG#eDEWxUT3HAQfVXWsCORrLElIX7J6kXPv4cWPmE1$Kthusw0JbFs$xUq57Gt$3XnppDFX" +
		"BOG#XNtjz0n$tltTN#FFXduRhe#2lXGzv3OPSyp1MD5Nb3fu41h0EHbyEmnuD$X7vpYNQH$" +
		"IBeV25x0R3VmN#laH3m5S4EpL4o7y9VFIZeXLmTwlx4ttaFhZxSOBu8R13HHWlXlQ33yQXG" +
		"kuFOcmu1k6tx3p3TbI#ia73bAo6$MFxm$TI$YBblsVx#xPG$k7AVqmnODpQ3$TKD0#wl0fr" +
		"mHuqBC7v2OZ7M54a#kIf28E$238gEW$XZt7VZy5XN1hH6hAu0JuO2mfG1cRW8vx6sFGLqKZ" +
		"qaSXtaDyfIkSQ8mxopOTyHru7VptyB#2$IJGAzgwW5tpKLm0Rc0zT78LnD0yC#wD$X55k#0" +
		"g4nzbbxN#pyh#BwMdC4HtGNVcdnyMlj$tHTTsuea$XFeSUYdxsfOg3NXHzYpZSLz5tTbmUv" +
		"b5vjo0EzrMq5UudbVO7ekwTuOl##PkAsmPM7V6d80nzBlhNZiTjKFVLy8MyJJzR7l8N8qyn" +
		"R4GFoB#Os$5XzECmzA47nk3YdU1ALLdelpsWcyMGVt4h5GSR7O4Dwl4zmjtXkgbuoBLdJ$X" +
		"zu7PJCfY2CEP2eszNQNgxBCLzbJyWNhQfEEJRAp6kATgw67skj1NyeIhTSDkFe5yLg$bFCV" +
		"WxpalCtxQbajE#jj$UMr#SZIvkKmxRAEN3RaR6PdX$c6lieknNCMpmQ8m9nHZBTdb6nQ6$j" +
		"r9pXMACAMDwmpyESQDL7FfJwrVXm$xsXFqeXivFH7ygnkLMIptrg3buCUO3Op1NA8OzABxG" +
		"ZiDCd$8mveJRsESbpy6#py7rIud6Gh#AqL#AbGre1LqklXWEDciiyXN3hXPVPL$ZqBVYQzm" +
		"wyy5MV9rxtlCjdD#eE62JYZ6l6GjRK7oJYeCjv6Byw#xXZkaKniyPk5uiT7wL7PSdPBL1NN" +
		"y3xZKxF0Ft7u4DA5RpsMBq$#9t$N8VA#pEItPudD3xTnBRHcyATnWSvYywxD0usAN9QamVz" +
		"xIRRZniKx6QAnR3$XI$bLXM#3JFFMtsX3y3A$hFr3CySU#ZJDYsuY#9TbNsf$WJE76$i1V5" +
		"MuXcSlYmySMm3yMmUn7eJF7FS9WF5CFc58jsWhqiHl#DWY#AiN5N51NDHnp6pl6mcT7cYCC" +
		"S8rgBg0pZNhGU7FhCU9GNnLoa3BeNnTedsece3MGHXOxirWm#P3iPxHRjWZHeboZMHb7qnG" +
		"cmUr7OXh8$u9V1GLUdTOCFcnDf0hy$$6$j#odyqFQBEYfVwMTq4Eh0F2#w5zoUTfo6#TfkS" +
		"D6zuGQhT69TYZ4YEXpNi8AEOWuKLVEp27GtYZ5pTyojebYdH8VPyQmDweNkHZ2ts1tphIZQ" +
		"DdgGodCKmkXNkqF$eXZ7eqUgUAm$eXY$Uq4kqTFXrFWJnVZS2#DS57qkwccxA6niL9HriHi" +
		"NmNWySvHxFWcoYbw2UANt6jfxccWRzBF8aN1$UCh372cATTeqN8jU3QVMED6h48TrM1Hple" +
		"Xe0$J30cLhYs9wNwRy63Fw6rDh#OYQpqHliVq9c4j6LT#Sy7ki$l8Sqj#WxWThqqPOjqQNm" +
		"wrKSSyWh6pOv0AL7lE1o78x76g4ytLWHdj7LwlhQs2lduB$Cle3vWzHsFc8a37wRu7GDzM$" +
		"ev1NMEbHLAqnwYbR7igp$V35wle7Bcylz8keqhie#Z$7$2sACJkAVZOD$IYAlbE0SREWq7E" +
		"FelzWN9wEyIwAlXUzLSMZhqs73aQntYf0$uqYVy5Y9UzNLHgrveaUgtoCon7CqwR3TaRHTm" +
		"imvosurwshO7YSVF#2RjohhgdrVQ7QwoXGkbFImFORem#NO5rGqbZ5ev$cQogivcibqFyIz" +
		"Elfq9SIZE$HJrHPiAibxTrw9sBzMl27gW$zi13zhAIZbqsLftIfKFNJ4ZKVADazFcsGGxh#" +
		"Q8Efy36Mbq0Ffly9NzI7Vbiup9CE$Ru4S#4PWcCVSAivK0d67$waOb1xDONNgMkOztL0Fo#" +
		"1cp4MFcn28URi9R0j1MgT4LshqZPHlfhFbgZrGy5asuzqKF57AVz4sw#bvXvvJUBk2ru9vl" +
		"ybc0zFmRoePBuTFpjk32evXwWEvdKbYhtiJnL$dF8NWrdPj1ACnGLAnqikLpxwHWbiGiarw" +
		"XmslL0nbLnl#o6i2qjKlow1BIbvmWxNXkqlmRXM8dJX1IMx6ubsSCRhE5RCdqlGVqkWlsCm" +
		"Roq9tEjoqnTYZb5G1px6jvArdd9UXtiRyUWlXMh$faJrbpcGHLZjvSo6FP#3kOhO7fY3CIg" +
		"2UvkDUkT0ddFU9PgByQW4Vk7xgenDYGoH#eX$3#uT#tpIjRO$5VErwU3gKAwTionhklAL7Q" +
		"Esjj$6sSyXQhUWl39ISR39QivDIVOZ#AN9yxRznGrJ8#N7zaGwANwr5j6Ey#STVwswhjPz#" +
		"jRazNGyDlNxsU4H$$bej7L8x5rYqHBwgEBylLvAVgtJf$xpYNqyZFdbb7cH6uweVbxGCDLx" +
		"SlFsUp$rj5txAMRcZozGUoyyf7mrPXMe$Ou2jGz7VyNon7JGBOFETiFiIV#r$cB$#2htN5$" +
		"WlrvwiVVSwr2FQQVH3dRJrzqvyTvgR$6VrpqvM0QjrPvjRCrLfwxjjrTpa$Pg$wU3idCTr7" +
		"vWLxK7KUSasz$DMMUhSxKtjTljdZYrZjwzjpUjYZjN#Q$vu$MPddjumd#jTAKRRlwI6owS8" +
		"$ORLVuLRdmz7sCYG#cFoQyLNXBRl$R4JVI4fxdXEiBEtmITRXnSbeQvLHxcWxJLZTkfUNbi" +
		"mUNeFtZkRKPmcWvgxwZJmRRVJUqPzLXY#xtLshRtq$vytHQvuKuFsNvdDKyilTozDZr1Pc2" +
		"vpmtF7ks$LgZwL3t3ZQi$p9j6fJl23UTXdSJKNaYXweFrrPWQkjAVZurLrxzIrxzoh$LHUz" +
		"#5c3CsyAnXTnhZOT$R4rPr5JwgqYqGpmqG$wcRfhwQO#bOUnLYVbH$lkVQovxxCMo$ACQYz" +
		"YRwgFbGdoziluVQ6#wfzY6xgJszxcgEs5tPnivgVw6pcZjq$jhsswb#sU4yvQlvS7irXhHN" +
		"Qwrs$Ms$xH3RRxEhkaTbsygSUNcGGtgrXxCpi$tM4VTQSyNGGet7BTGpY1ONAVyfvQlzjfR" +
		"gMKTBnTPIhOTQtgLypngXhQCNVfvsizrmUu$kjFSy5#gmIlcVkN5TkYZ$LDllDTczrbtjc$" +
		"PGzzX3yNLPO$jTFSypUYhcdklTkBvgxTnNsSY#BoPoxr6i$75nyMhFSu#0FSy6PmV4UUupZ" +
		"7LQ4TOI3NUop$DETAyrLFgJf#QqHR1hHRqGhzeaRuERjf7QrmftYw$FasQS6yuNpt#mFcYa" +
		"T2vyiYUTUkuRLd8k4i#YZi6wIArDmgUxQHkhlQomMdVkhFOsMoSypuOjNHyVbuuJpnqIutR" +
		"SRFibovFawUI6w$H9l5xxGVzvdLMLO#JxL2v$oPjkU6Sr7eHdk76rsdckgpbuhVFSk1rK7z" +
		"b1wSmOPOjg#PvPUifunVQB1jb#v00uh0UOiWDSxCDljSFDOZBzrVPhx#2MqwnhUlUvmuU9S" +
		"Stckk5YyQOKvbwydYVEivSmkqJ5jNRZ2cfxmdLilvsojGLDFDS6nTNhsMTjzhBtMd9#yOoh" +
		"M7rVeEk1dlZk5UTbgyg$tcQ#$xoPclVLzjJ3hy5zgFd1j0OOEx4MB9YT2hkT9tot6swkT2Q" +
		"izYdo1tYkpL5ndcVLEnvj#wLghJLUwL3#9a##gsq$qiADcw7YICx$qBxATcXgRqVlglnpt3" +
		"oDdVrTDwv9syIuV6KJcvmKVBzDrlhFYzUXteVjSDFwmNcQpaeI$q10NC9w4uUobtbV##DdU" +
		"#GxxLXSR#QU5s0#F4EjCIDZOdlo$lmprLWL#jOJ5wjBpjSXMpLUQwVPlgxsCKEjt3nvQl#h" +
		"MEtTQ6elffTdNZN1nrwHm$sy2VrL#uB5QfzjWcV#EFaGLNTBppqhlM2#TGziyS#sFxqJqez" +
		"5EZN6vs$qfukelPvYDIyhKNkRnMfFhkxGHCwsddcnABl$u#xvJ3NkHMuLU$Y9UMSkLDSzTc" +
		"EcUeOPKVTEQczTKtF2a7hs7Lfd##5Pk9$7aKyzuoyGpmISiHlb52NM6r7VmOYgxtiLg6VEK" +
		"RKsvghkFTLUPLHpynQe#L2qix$CMMhFiq3fLC50f3d9lLuwmGspCh5l5jkt3tAurZVPjV8S" +
		"v345tCFTyrbgJLk0CI0wFp7zh5dgkh8PuHN8h$Qx2bOf5YNpy2#ujaNbK$k11PjidvRPFbV" +
		"FXlBKdc#UqjEesXFDLpeM#K75n$RyLLrCsHBcstTsUSKpfG43tVEcpoQcOM9VNktVQMhyYW" +
		"PytwxWB3SSdUc$5ksbqjpYYJiaYCcztYuS73yWwVDQLSUzH1C7bvV6JXTMpwDA9lZZyzLt1" +
		"4lc9kRfkYYsru8sEvsedtXsVpUODiAsuNpy1uYhGpIm5EuWyJs42XX#WrFFFqETo7DO6wqD" +
		"rdfhdRd2F5cUFmc7dcazBCzmZzRTrbtMdTOT5dJClCUysxhTkiswrLfkBJDlCq#qph5UiCw" +
		"LQMVW#btc7GXDiwPQKwp924s2MoElFW7t6Dn3gjxxh2$DxiZH3Qu7phTOdrYVMP#QZUph9c" +
		"OOPW5SBRF4#iRwMiMsS$EONV7vBvnXTZ4Zycfzk7mpQXQhrArbwh0CruNBCulCGdMj5Uhym" +
		"knfVMxzQlrY$MpzP6spVhH#iBwtjbhVMT$AD6tDCdCNixtPnjpLR63MSwM6VFSZ$oC83O3h" +
		"3zS7RW$4FMXzXH0pJ3kbOSZFlus$rFblylDduoTyRZD#jBw4$xlJ6akj6$5vWtMTTQrv7q8" +
		"7mis5cstDD9ysLvhFekpdu5w0MmK7sPeOoysNuDw0Unjk4zo7vbRpE$Yu3$CR4z8p1TMNvX" +
		"Vc3#Rt27qEzvdvgVap$7#iJ#Gz$I49mkON23zbFc$#fExrBtNzDolVt6R#QBveIVcQlrX5L" +
		"g6vsf1jOtnb5KZ$I$dvcV6fols9yP6nsVZG#42MdcU5J4l6c#PQoxGCwr$h7#jlwo$hJqlM" +
		"R$wjQllTECKusLoFq0OupE$CZN3lmg4aytrpi$aU$BVCT$3v6johSA$8zdxJVDbfft5mdRt" +
		"wRfmaFqzKyjO4ZALR79zCNZd4R6aSR4MSz8UOBMH9Msnvc7$Apr#DZysFPUWZfFbSrHQIdx" +
		"ewu$9JCvuqVx8#5zg6bA$0eQqCt9U1jZFGXWRMbmRQrNWQ3ZtFU1GElSzu40uwODm3ToVSx" +
		"N3BuMw6kz5pHriyuHkyzsgYBvleToPADT7tJ9Hi2fr5wIRweOaQp0VWxZUM8kzDnll6UyOc" +
		"unQ4bnaO$OtR3FHvumxZBdp24XXt6z1w0oKOo6qyO3o5JsYZyGpSIZZKPJncG3UDrN0l6cl" +
		"nYROmq8B6EkDLurq3hML0HusDnbi6vae6TDPutNZD8HxhXCPxMg3K2UteYTt12JKrlZ0#yT" +
		"pt14#gvawecITsPoUqayg3Ux3cMBECWwphZGEjcwpLrYhhHTYsvwtdh6UjPwodhPNMK#PLr" +
		"k$MR#QLvXBp2kGvJ#Qy74vQGFDI#RdON6GkD2z1w6AuY#0kCC$7vuNc0lCoMBdnrZXhh3N6" +
		"6crXjMblabjhhVsjKTP8QuIrdxMlDTmQPWsrXbZxM8D5Rx3wniYjFULdV#TyLuexh9QMi4A" +
		"zdVEkokzYjSFdC#gieI$FBl9pHqjAr6fgDP5#O#UwjCbM0wkUXJ77gkN4ruO43x8k5f#6j9" +
		"WukqYUVMFLj#hAD2NoCshridQtTXFs0xO0VSRyoK3$iTfOq#NrrlAppEfijRVQ8jJ9weWqT" +
		"reTL4sbravEwyvNDLtlzIr7Nn3sw49wXpUdTJRScN2dmPqUisVMASxrauNrTCvESiFcf9Zj" +
		"b5TEz5oPw0bFSKAJ3MYiTI7S0ki2cUSIQw7AVRDnaFIlifPObrgNn$8O4wr5Fjgpx8T#rgb" +
		"mKaBMyN1ONrb7oxDvS4TQHrY7MuTPXrg7cBUR9ra78#uWXsAv$5m6TxFCSOkXhfatkVKuSK" +
		"lb9#emKOTv31pgCO#2EymyHEQ$Xpo7ESOym1nXZdBvpNsz$EOmk25mUy4DZjLZNMrTQLrce" +
		"QzPrrZdMxA$MIV07OTKq75pTuIFKINSAZznrJpE8wN5vi7cWUOiSuwyAkOe1vbppPdcR7EQ" +
		"EHrdc66Ra8rvEDoHvg7cZUODvlNcTUQrvZNcBRux66tkR#vdZlJSmN398#wv5znkyinxJqF" +
		"Xze4R1BSthWdxYnM6YLviea#R$H0dBE8eup93sWvZjlnS33V9M6XSecf2cngJZLd637bsiV" +
		"mK$Un26JhFM21zs1X3sY7ZTFavto4zJNwUQPnXd6DSOCpqjEOYwsthLUiLumVZUsF$MApra" +
		"kMCeCPMkEzaxBiKU5XlmRrclMczORqkp$6ftSTc4wCpAt2tA7UiSiSfTto0Eq6vAst72k3$" +
		"2dSLQT8TZR1my#2E8Suc8SqaqfGJvwJYxFWm$33oVOdqN#Ay7jBiXZZXTeVhHPo#nZNXjYB" +
		"yFOLe0y8nTxDq6Ys5dwgxbSJlV#dAXJo#S7dqCyfx1In3KFyGf5q9fXqGtW5n#V2zhYZHqS" +
		"V8yp7AV0$Xzn1#0$uRyDz4$WZI25SBTVo6#dv3VROBUtpXyftpbv3$9UHV9vrEQr7EC9Gn3" +
		"5n3uGiNHLmn$18Am#Kh5$7umXNGNwZJTc7fNa2PBw1CsuNeRt3zZRXDA7iuoXkESdU47#yu" +
		"N1#a$KKwhfpEzaNylWWlXtiPt2$Z#dFmO#vvd3yh7QSxS1xaxapJVHJWxiQzt8Fx#mJkVfp" +
		"VXVgsm3s0kc$3UJBt88NOVhYF$N3$jjFO2DpJ2FWxmPKYN8eo39HbmByNzNmAzn3gkOyYz1" +
		"dal3VI23SOvPdISNfOEeqUWVy8$4VXFmxt6F8#0TzsEji7#VP1FJk3epxIFOdu9v7cH9GJS" +
		"r$1lGxtj7GSYqlXTCS$tNQi0SfgW38inA#0lmB#MOuBqMb8Tnfqp7RvT3REXJiPvNhTASXx" +
		"Ajo52DjEKuxHUV35RqzUWF05qhV32r3E0jGHyoz2t4MeD#Oknld5qkTq2SANIDzsYt2#IFf" +
		"#jnZnYwNFwNA4BuT$1Vmhu2#1lmJ#rV2lXdy3$1lWtmZ$HjH$4tpX5Y8k7RSCCfmg#xhe#v" +
		"hGQw4Nq5DDs1$P5qIVVn7t#IBQh1ckZqJSIAHlJdbmOJWMwFPITkiQZxiMPUoFQ$kZd1Qev" +
		"tV4nToVIFyducodimEGxW24hqFyzSZdsbZXTDcNH5zu2hhvEJWQ8RuHuhtSgv1$5U9i5w9$" +
		"KDO$YBETxl652x7Ho3SQvRI4tnBrsOvxVE5qrWH#OwHfZ7WCHB0rUShbItSQc5mNyTWyuI8" +
		"UNxY2s7dCZYbNwF65AqgmvQulNDYnSxRBeyiWWyiGlXJ#fRZNgn1t5TAi1lFRY7iRSSAzW$" +
		"DtfCzP2FSKaZvdVH7kAtrEyv5tFkgO3zRvuBPTGSBvDoZt6wJ$0luNoDiASce5VmpyCOX$2" +
		"$72RRGTOyhjOZjQ0vOrIFS1$0#GJuU$07KlGDqBKDS2rFCJulv0cZ#GVfjqdBw5$otYlxCT" +
		"couTPpFWpu2$A$nTKKSP$3BuhU7lWRInyVS7rF4Zd1Y3ra5c9o7k99Hx4ixzVYoUUyuTn$R" +
		"qk06EqvHZhBzqcdACjP6E1xgskDPM#gvhXxXsqazqxN6jlVGhTXsGjeFqNTSHSHsbpradX3" +
		"j9dxFE27UMFcTT4EuYVSwQ8jnK#fmDH7WW#f1mWn0MhfypFtBcIlG#v2JSXv3rPjYGGiGBf" +
		"o6DXhpZu8$3UNVqiva8OoR9niCVZxXPqX6RWFC92FU0tmFfUg2SsjBUC#dEWPwS2vim4NLF" +
		"G$ffI8lLA1nZM171CPO7Fm$#PFYJaKUiMf#1B$O9NeF$AlnNSHqh03Z6neflqy3l9ft6iCg" +
		"0OmnhNpZ6UagdaPZ1leimLh5mZDRZV3tEiLA5O$IlT1hT$d#4NKZE");
 // Generated from parser/JavaParser.all
class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      errors.add(new Problem(null, e.getMessage(), e.line, e.column, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
    }
    public void syntaxError(Symbol token) {
      int line = token.getLine(token.getStart());
      int column = token.getColumn(token.getStart());
      int endLine = token.getLine(token.getEnd());
      int endColumn = token.getColumn(token.getEnd());
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      errors.add(new Problem(null, "unexpected token \"" + value + "\"", line, column, endLine, endColumn, Problem.Severity.ERROR, Problem.Kind.SYNTACTIC));
    }
    public void unexpectedTokenRemoved(Symbol token) {
    }
    public void missingTokenInserted(Symbol token) {
    }
    public void misspelledTokenReplaced(Symbol token) {
    }
    public void errorPhraseRemoved(Symbol error) {
    }
  }

        {
            report = new Events(); // Use error handler in parser
        }

   public CompilationUnit parse(java.io.InputStream is, String fileName) throws java.io.IOException, beaver.Parser.Exception {
     CompilationUnit cu;
     errors = new ArrayList();
     try {
       scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
       cu = (CompilationUnit)parse(scanner);
     } catch(Parser.Exception e) {
       // build empty compilation unit for failed error recovery
       cu = new CompilationUnit();
     } catch(Error e) {
       cu = new CompilationUnit();
       errors.add(new Problem(null, e.getMessage(), 0, 0, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
     }
     for(java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
       Problem p = (Problem)iter.next();
       p.setFileName(fileName);
       cu.addParseError(p);
     }
     return cu;
   }
   protected java.util.Collection errors = new ArrayList();

	public JavaParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = compilation_unit.cu
			{
					final Symbol _symbol_cu = _symbols[offset + 1];
					final CompilationUnit cu = (CompilationUnit) _symbol_cu.value;
					 return cu;
			}
			case 1: // literal = INTEGER_LITERAL.INTEGER_LITERAL
			{
					final Symbol INTEGER_LITERAL = _symbols[offset + 1];
					 return new IntegerLiteral(INTEGER_LITERAL);
			}
			case 2: // literal = LONG_LITERAL.LONG_LITERAL
			{
					final Symbol LONG_LITERAL = _symbols[offset + 1];
					 return new LongLiteral(LONG_LITERAL);
			}
			case 3: // literal = FLOATING_POINT_LITERAL.FLOATING_POINT_LITERAL
			{
					final Symbol FLOATING_POINT_LITERAL = _symbols[offset + 1];
					 return new FloatingPointLiteral(FLOATING_POINT_LITERAL);
			}
			case 4: // literal = DOUBLE_LITERAL.DOUBLE_LITERAL
			{
					final Symbol DOUBLE_LITERAL = _symbols[offset + 1];
					 return new DoubleLiteral(DOUBLE_LITERAL);
			}
			case 5: // literal = BOOLEAN_LITERAL.BOOLEAN_LITERAL
			{
					final Symbol BOOLEAN_LITERAL = _symbols[offset + 1];
					 return new BooleanLiteral(BOOLEAN_LITERAL);
			}
			case 6: // literal = CHARACTER_LITERAL.CHARACTER_LITERAL
			{
					final Symbol CHARACTER_LITERAL = _symbols[offset + 1];
					 return new CharacterLiteral(CHARACTER_LITERAL);
			}
			case 7: // literal = STRING_LITERAL.STRING_LITERAL
			{
					final Symbol STRING_LITERAL = _symbols[offset + 1];
					 return new StringLiteral(STRING_LITERAL);
			}
			case 8: // literal = NULL_LITERAL.NULL_LITERAL
			{
					final Symbol NULL_LITERAL = _symbols[offset + 1];
					 return new NullLiteral(NULL_LITERAL);
			}
			case 9: // type = primitive_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 10: // type = reference_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 11: // primitive_type = numeric_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 12: // primitive_type = BOOLEAN.BOOLEAN
			{
					final Symbol BOOLEAN = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("boolean");
			}
			case 13: // numeric_type = integral_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 14: // numeric_type = floating_point_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 15: // integral_type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("byte");
			}
			case 16: // integral_type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("short");
			}
			case 17: // integral_type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("int");
			}
			case 18: // integral_type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("long");
			}
			case 19: // integral_type = CHAR.CHAR
			{
					final Symbol CHAR = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("char");
			}
			case 20: // floating_point_type = FLOAT.FLOAT
			{
					final Symbol FLOAT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("float");
			}
			case 21: // floating_point_type = DOUBLE.DOUBLE
			{
					final Symbol DOUBLE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("double");
			}
			case 22: // reference_type = class_or_interface_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 23: // reference_type = array_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 24: // class_type = class_or_interface_type.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 25: // interface_type = class_or_interface_type.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 26: // array_type = primitive_type.t dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return t.addArrayDims(d);
			}
			case 27: // array_type = name.n dims.d
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return n.addArrayDims(d);
			}
			case 28: // name = simple_name.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Access s = (Access) _symbol_s.value;
					 return s;
			}
			case 29: // name = qualified_name.q
			{
					final Symbol _symbol_q = _symbols[offset + 1];
					final Access q = (Access) _symbol_q.value;
					 return q;
			}
			case 30: // simple_name = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new ParseName(IDENTIFIER);
			}
			case 31: // qualified_name = name.n DOT.DOT simple_name.i
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return n.qualifiesAccess(i);
			}
			case 32: // compilation_unit = package_declaration.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					 return new CompilationUnit(p.getID(), new List(), new List());
			}
			case 33: // compilation_unit = package_declaration.p import_declarations.i
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return new CompilationUnit(p.getID(), i, new List());
			}
			case 34: // compilation_unit = package_declaration.p type_declarations.t
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit(p.getID(), new List(), t);
			}
			case 35: // compilation_unit = package_declaration.p import_declarations.i type_declarations.t
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit(p.getID(), i, t);
			}
			case 36: // compilation_unit = 
			{
					 return new CompilationUnit("", new List(), new List());
			}
			case 37: // compilation_unit = import_declarations.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					 return new CompilationUnit("", i, new List());
			}
			case 38: // compilation_unit = type_declarations.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit("", new List(), t);
			}
			case 39: // compilation_unit = import_declarations.i type_declarations.t
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit("", i, t);
			}
			case 40: // import_declarations = import_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ImportDecl i = (ImportDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 41: // import_declarations = import_declarations.l import_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final ImportDecl i = (ImportDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 42: // type_declarations = type_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return !(t instanceof EmptyType) ? new List().add(t) : new List() ;
			}
			case 43: // type_declarations = type_declarations.l type_declaration.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return !(t instanceof EmptyType) ? l.add(t) : l;
			}
			case 44: // package_declaration = PACKAGE.PACKAGE name_decl.n SEMICOLON.SEMICOLON
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final IdUse n = (IdUse) _symbol_n.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return n;
			}
			case 45: // name_decl = simple_name_decl.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final IdUse s = (IdUse) _symbol_s.value;
					 return s;
			}
			case 46: // name_decl = qualified_name_decl.q
			{
					final Symbol _symbol_q = _symbols[offset + 1];
					final IdUse q = (IdUse) _symbol_q.value;
					 return q;
			}
			case 47: // simple_name_decl = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new IdUse(IDENTIFIER);
			}
			case 48: // qualified_name_decl = name_decl.n DOT.DOT IDENTIFIER.i
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final IdUse n = (IdUse) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol i = _symbols[offset + 3];
					 return new IdUse(n.getID() + "." + ((String)i.value));
			}
			case 49: // import_declaration = single_type_import_declaration.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ImportDecl s = (ImportDecl) _symbol_s.value;
					 return s;
			}
			case 50: // import_declaration = type_import_on_demand_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ImportDecl t = (ImportDecl) _symbol_t.value;
					 return t;
			}
			case 51: // single_type_import_declaration = IMPORT.IMPORT name.n SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SingleTypeImportDecl(n);
			}
			case 52: // type_import_on_demand_declaration = IMPORT.IMPORT name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol MULT = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new TypeImportOnDemandDecl(n);
			}
			case 53: // type_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return c;
			}
			case 54: // type_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return i;
			}
			case 55: // type_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyType(new Modifiers(), "EmptyType", new Opt(), new List());
			}
			case 56: // modifiers = modifier.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifier m = (Modifier) _symbol_m.value;
					 return new List().add(m);
			}
			case 57: // modifiers = modifiers.l modifier.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final Modifier m = (Modifier) _symbol_m.value;
					 return l.add(m);
			}
			case 58: // modifier = PUBLIC.PUBLIC
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					 return new Modifier("public");
			}
			case 59: // modifier = PROTECTED.PROTECTED
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					 return new Modifier("protected");
			}
			case 60: // modifier = PRIVATE.PRIVATE
			{
					final Symbol PRIVATE = _symbols[offset + 1];
					 return new Modifier("private");
			}
			case 61: // modifier = STATIC.STATIC
			{
					final Symbol STATIC = _symbols[offset + 1];
					 return new Modifier("static");
			}
			case 62: // modifier = ABSTRACT.ABSTRACT
			{
					final Symbol ABSTRACT = _symbols[offset + 1];
					 return new Modifier("abstract");
			}
			case 63: // modifier = FINAL.FINAL
			{
					final Symbol FINAL = _symbols[offset + 1];
					 return new Modifier("final");
			}
			case 64: // modifier = NATIVE.NATIVE
			{
					final Symbol NATIVE = _symbols[offset + 1];
					 return new Modifier("native");
			}
			case 65: // modifier = SYNCHRONIZED.SYNCHRONIZED
			{
					final Symbol SYNCHRONIZED = _symbols[offset + 1];
					 return new Modifier("synchronized");
			}
			case 66: // modifier = TRANSIENT.TRANSIENT
			{
					final Symbol TRANSIENT = _symbols[offset + 1];
					 return new Modifier("transient");
			}
			case 67: // modifier = VOLATILE.VOLATILE
			{
					final Symbol VOLATILE = _symbols[offset + 1];
					 return new Modifier("volatile");
			}
			case 68: // modifier = STRICTFP.STRICTFP
			{
					final Symbol STRICTFP = _symbols[offset + 1];
					 return new Modifier("strictfp");
			}
			case 69: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), new List(), b);
			}
			case 70: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), new List(), b);
			}
			case 71: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER super.s class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, s, new List(), b);
			}
			case 72: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER super.s class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, s, new List(), b);
			}
			case 73: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), i, b);
			}
			case 74: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), i, b);
			}
			case 75: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER super.s interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, s, i, b);
			}
			case 76: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER super.s interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, s, i, b);
			}
			case 77: // super = EXTENDS.EXTENDS class_type.c
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final Access c = (Access) _symbol_c.value;
					 return new Opt(c);
			}
			case 78: // interfaces = IMPLEMENTS.IMPLEMENTS interface_type_list.i
			{
					final Symbol IMPLEMENTS = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return i;
			}
			case 79: // interface_type_list = interface_type.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Access i = (Access) _symbol_i.value;
					 return new List().add(i);
			}
			case 80: // interface_type_list = interface_type_list.l COMMA.COMMA interface_type.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return l.add(i);
			}
			case 81: // class_body = LBRACE.LBRACE class_body_declarations_opt.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return c;
			}
			case 82: // class_body_declarations = class_body_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return new List().add(c);
			}
			case 83: // class_body_declarations = class_body_declarations.l class_body_declaration.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return l.add(c);
			}
			case 84: // class_body_declaration = class_member_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 85: // class_body_declaration = instance_initializer.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InstanceInitializer i = (InstanceInitializer) _symbol_i.value;
					 return i;
			}
			case 86: // class_body_declaration = static_initializer.si
			{
					final Symbol _symbol_si = _symbols[offset + 1];
					final StaticInitializer si = (StaticInitializer) _symbol_si.value;
					 return si;
			}
			case 87: // class_body_declaration = constructor_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ConstructorDecl c = (ConstructorDecl) _symbol_c.value;
					 return c;
			}
			case 88: // class_member_declaration = field_declaration.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final BodyDecl f = (BodyDecl) _symbol_f.value;
					 return f;
			}
			case 89: // class_member_declaration = method_declaration.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					 return m;
			}
			case 90: // class_member_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new MemberClassDecl(c);
			}
			case 91: // class_member_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 92: // class_member_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new InstanceInitializer(new Block());
			}
			case 93: // field_declaration = type.t variable_declarators.v SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new FieldDecl(new Modifiers(new List()), t, v);
			}
			case 94: // field_declaration = modifiers.m type.t variable_declarators.v SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final List v = (List) _symbol_v.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new FieldDecl(new Modifiers(m), t, v);
			}
			case 95: // variable_declarators = variable_declarator.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new List().add(v);
			}
			case 96: // variable_declarators = variable_declarators.l COMMA.COMMA variable_declarator.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return l.add(v);
			}
			case 97: // variable_declarator = variable_declarator_id.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return v;
			}
			case 98: // variable_declarator = variable_declarator_id.v EQ.EQ variable_initializer.i
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expr i = (Expr) _symbol_i.value;
					 v.setInit(i); return v;
			}
			case 99: // variable_declarator_id = IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return new VariableDecl(IDENTIFIER, d, new Opt());
			}
			case 100: // variable_initializer = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 101: // variable_initializer = array_initializer.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ArrayInit a = (ArrayInit) _symbol_a.value;
					 return a;
			}
			case 102: // method_declaration = method_header.m method_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Opt b = (Opt) _symbol_b.value;
					 m.setBlockOpt(b); return m;
			}
			case 103: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt());
			}
			case 104: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt());
			}
			case 105: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt());
			}
			case 106: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt());
			}
			case 107: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt());
			}
			case 108: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt());
			}
			case 109: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt());
			}
			case 110: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt());
			}
			case 111: // method_header = VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt());
			}
			case 112: // method_header = modifiers.m VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol VOID = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt());
			}
			case 113: // formal_parameter_list = formal_parameter.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ParameterDeclaration f = (ParameterDeclaration) _symbol_f.value;
					 return new List().add(f);
			}
			case 114: // formal_parameter_list = formal_parameter_list.l COMMA.COMMA formal_parameter.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_f = _symbols[offset + 3];
					final ParameterDeclaration f = (ParameterDeclaration) _symbol_f.value;
					 return l.add(f);
			}
			case 115: // formal_parameter = type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER);
			}
			case 116: // formal_parameter = modifiers.m type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new ParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER);
			}
			case 117: // throws = THROWS.THROWS class_type_list.l
			{
					final Symbol THROWS = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 118: // class_type_list = class_type.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Access c = (Access) _symbol_c.value;
					 return new List().add(c);
			}
			case 119: // class_type_list = class_type_list.l COMMA.COMMA class_type.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final Access c = (Access) _symbol_c.value;
					 return l.add(c);
			}
			case 120: // method_body = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return new Opt(b);
			}
			case 121: // method_body = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new Opt();
			}
			case 122: // static_initializer = STATIC.STATIC block.b
			{
					final Symbol STATIC = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new StaticInitializer(b);
			}
			case 123: // instance_initializer = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return new InstanceInitializer(b);
			}
			case 124: // constructor_declaration = IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 6];
					final Symbol RBRACE = _symbols[offset + 7];
					 Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), b);
			}
			case 125: // constructor_declaration = modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 7];
					final Symbol RBRACE = _symbols[offset + 8];
					 Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), b);
			}
			case 126: // constructor_declaration = IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 6];
					final Symbol _symbol_c = _symbols[offset + 7];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 8];
					 Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), b);
			}
			case 127: // constructor_declaration = modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 7];
					final Symbol _symbol_c = _symbols[offset + 8];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 9];
					 Block b = new Block(new List()); new List().setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), b);
			}
			case 128: // constructor_declaration = IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.l RBRACE.RBRACE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 8];
					 Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), b);
			}
			case 129: // constructor_declaration = modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.l RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 9];
					 Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), b);
			}
			case 130: // constructor_declaration = IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 6];
					final Symbol _symbol_c = _symbols[offset + 7];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 9];
					 Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), b);
			}
			case 131: // constructor_declaration = modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 7];
					final Symbol _symbol_c = _symbols[offset + 8];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 10];
					 Block b = new Block(l); l.setStart(LBRACE.getStart() + 1); b.setStart(LBRACE.getStart()); b.setEnd(RBRACE.getEnd());
       return new ConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), b);
			}
			case 132: // explicit_constructor_invocation = THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol THIS = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 ConstructorAccess c = new ConstructorAccess("this", l);
       c.setStart(THIS.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c);
			}
			case 133: // explicit_constructor_invocation = SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c);
			}
			case 134: // explicit_constructor_invocation = primary.p DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(p.qualifiesAccess(c));
			}
			case 135: // explicit_constructor_invocation = name.n DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(n.qualifiesAccess(c));
			}
			case 136: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(new List()), IDENTIFIER, new List(), b);
			}
			case 137: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(m), IDENTIFIER, new List(), b);
			}
			case 138: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER extends_interfaces.i interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(new List()), IDENTIFIER, i, b);
			}
			case 139: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER extends_interfaces.i interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(m), IDENTIFIER, i, b);
			}
			case 140: // extends_interfaces = EXTENDS.EXTENDS interface_type.i
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final Access i = (Access) _symbol_i.value;
					 return new List().add(i);
			}
			case 141: // extends_interfaces = extends_interfaces.l COMMA.COMMA interface_type.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return l.add(i);
			}
			case 142: // interface_body = LBRACE.LBRACE interface_member_declarations_opt.i RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return i;
			}
			case 143: // interface_member_declarations = interface_member_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 144: // interface_member_declarations = interface_member_declarations.l interface_member_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 145: // interface_member_declaration = constant_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 146: // interface_member_declaration = abstract_method_declaration.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final BodyDecl a = (BodyDecl) _symbol_a.value;
					 return a;
			}
			case 147: // interface_member_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new MemberClassDecl(c);
			}
			case 148: // interface_member_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 149: // interface_member_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new StaticInitializer(new Block());
			}
			case 150: // constant_declaration = field_declaration.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final BodyDecl f = (BodyDecl) _symbol_f.value;
					 return f;
			}
			case 151: // abstract_method_declaration = method_header.m SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return m;
			}
			case 152: // array_initializer = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ArrayInit(new List());
			}
			case 153: // array_initializer = LBRACE.LBRACE variable_initializers.v RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayInit(v);
			}
			case 154: // array_initializer = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayInit(new List());
			}
			case 155: // array_initializer = LBRACE.LBRACE variable_initializers.v COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ArrayInit(v);
			}
			case 156: // variable_initializers = variable_initializer.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Expr v = (Expr) _symbol_v.value;
					 return new List().add(v);
			}
			case 157: // variable_initializers = variable_initializers.l COMMA.COMMA variable_initializer.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final Expr v = (Expr) _symbol_v.value;
					 return l.add(v);
			}
			case 158: // block = LBRACE.LBRACE block_statements_opt.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 159: // block_statements = block_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new List().add(b);
			}
			case 160: // block_statements = block_statements.l block_statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 161: // block_statement = local_variable_declaration_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					 return l;
			}
			case 162: // block_statement = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new LocalClassDeclStmt(c);
			}
			case 163: // block_statement = statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 164: // local_variable_declaration_statement = local_variable_declaration.l SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return l;
			}
			case 165: // local_variable_declaration = type.t variable_declarators.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new VarDeclStmt(new Modifiers(new List()), t, l);
			}
			case 166: // local_variable_declaration = modifiers.m type.t variable_declarators.l
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new VarDeclStmt(new Modifiers(m), t, l);
			}
			case 167: // statement = statement_without_trailing_substatement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 168: // statement = labeled_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LabeledStmt l = (LabeledStmt) _symbol_l.value;
					 return l;
			}
			case 169: // statement = if_then_statement.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 170: // statement = if_then_else_statement.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 171: // statement = while_statement.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final WhileStmt w = (WhileStmt) _symbol_w.value;
					 return w;
			}
			case 172: // statement = for_statement.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ForStmt f = (ForStmt) _symbol_f.value;
					 return f;
			}
			case 173: // statement_without_trailing_substatement = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return b;
			}
			case 174: // statement_without_trailing_substatement = empty_statement.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final EmptyStmt e = (EmptyStmt) _symbol_e.value;
					 return e;
			}
			case 175: // statement_without_trailing_substatement = expression_statement.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return e;
			}
			case 176: // statement_without_trailing_substatement = switch_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SwitchStmt s = (SwitchStmt) _symbol_s.value;
					 return s;
			}
			case 177: // statement_without_trailing_substatement = do_statement.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DoStmt d = (DoStmt) _symbol_d.value;
					 return d;
			}
			case 178: // statement_without_trailing_substatement = break_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final BreakStmt b = (BreakStmt) _symbol_b.value;
					 return b;
			}
			case 179: // statement_without_trailing_substatement = continue_statement.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ContinueStmt c = (ContinueStmt) _symbol_c.value;
					 return c;
			}
			case 180: // statement_without_trailing_substatement = return_statement.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ReturnStmt r = (ReturnStmt) _symbol_r.value;
					 return r;
			}
			case 181: // statement_without_trailing_substatement = synchronized_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SynchronizedStmt s = (SynchronizedStmt) _symbol_s.value;
					 return s;
			}
			case 182: // statement_without_trailing_substatement = throw_statement.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ThrowStmt t = (ThrowStmt) _symbol_t.value;
					 return t;
			}
			case 183: // statement_without_trailing_substatement = try_statement.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TryStmt t = (TryStmt) _symbol_t.value;
					 return t;
			}
			case 184: // statement_without_trailing_substatement = assert_statement.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final AssertStmt a = (AssertStmt) _symbol_a.value;
					 return a;
			}
			case 185: // statement_no_short_if = statement_without_trailing_substatement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 186: // statement_no_short_if = labeled_statement_no_short_if.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LabeledStmt l = (LabeledStmt) _symbol_l.value;
					 return l;
			}
			case 187: // statement_no_short_if = if_then_else_statement_no_short_if.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 188: // statement_no_short_if = while_statement_no_short_if.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final WhileStmt w = (WhileStmt) _symbol_w.value;
					 return w;
			}
			case 189: // statement_no_short_if = for_statement_no_short_if.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ForStmt f = (ForStmt) _symbol_f.value;
					 return f;
			}
			case 190: // if_then_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new IfStmt(e, s, new Opt());
			}
			case 191: // if_then_else_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 192: // if_then_else_statement_no_short_if = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement_no_short_if.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 193: // empty_statement = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyStmt();
			}
			case 194: // labeled_statement = IDENTIFIER.id COLON.COLON statement.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 195: // labeled_statement_no_short_if = IDENTIFIER.id COLON.COLON statement_no_short_if.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 196: // expression_statement = statement_expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return e;
			}
			case 197: // statement_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(a);
			}
			case 198: // statement_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 199: // statement_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 200: // statement_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 201: // statement_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 202: // statement_expression = method_invocation.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Access i = (Access) _symbol_i.value;
					 return new ExprStmt(i);
			}
			case 203: // statement_expression = class_instance_creation_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 204: // switch_statement = SWITCH.SWITCH LPAREN.LPAREN expression.e RPAREN.RPAREN switch_block.l
			{
					final Symbol SWITCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final Block l = (Block) _symbol_l.value;
					 return new SwitchStmt(e, l);
			}
			case 205: // switch_block = LBRACE.LBRACE switch_block_statement_groups.l switch_labels.s RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final List s = (List) _symbol_s.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 for(int ii = 0; ii < s.getNumChildNoTransform(); ii++) l.add(s.getChildNoTransform(ii)); return new Block(l);
			}
			case 206: // switch_block = LBRACE.LBRACE switch_block_statement_groups.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 207: // switch_block = LBRACE.LBRACE switch_labels.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 208: // switch_block = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 209: // switch_block_statement_groups = switch_block_statement_group.g
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final List g = (List) _symbol_g.value;
					 return g;
			}
			case 210: // switch_block_statement_groups = switch_block_statement_groups.l switch_block_statement_group.g
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_g = _symbols[offset + 2];
					final List g = (List) _symbol_g.value;
					 for(int ii = 0; ii < g.getNumChildNoTransform(); ii++)
           l.add(g.getChildNoTransform(ii));
         return l;
			}
			case 211: // switch_block_statement_group = switch_labels.l block_statements.bl
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_bl = _symbols[offset + 2];
					final List bl = (List) _symbol_bl.value;
					 for(int ii = 0; ii < bl.getNumChildNoTransform(); ii++)
          l.add(bl.getChildNoTransform(ii));
          return l;
			}
			case 212: // switch_labels = switch_label.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Case s = (Case) _symbol_s.value;
					 return new List().add(s);
			}
			case 213: // switch_labels = switch_labels.l switch_label.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Case s = (Case) _symbol_s.value;
					 return l.add(s);
			}
			case 214: // switch_label = CASE.CASE constant_expression.e COLON.COLON
			{
					final Symbol CASE = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					 return new ConstCase(e);
			}
			case 215: // switch_label = DEFAULT.DEFAULT COLON.COLON
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					 return new DefaultCase();
			}
			case 216: // while_statement = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 217: // while_statement_no_short_if = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 218: // do_statement = DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol DO = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol WHILE = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new DoStmt(s, e);
			}
			case 219: // for_statement = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, e, u, s);
			}
			case 220: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, e, u, s);
			}
			case 221: // for_init = statement_expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 222: // for_init = local_variable_declaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final VarDeclStmt d = (VarDeclStmt) _symbol_d.value;
					 return new List().add(d);
			}
			case 223: // for_update = statement_expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 224: // statement_expression_list = statement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return new List().add(e);
			}
			case 225: // statement_expression_list = statement_expression_list.l COMMA.COMMA statement_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return l.add(e);
			}
			case 226: // break_statement = BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(((String)id.value));
			}
			case 227: // break_statement = BREAK.BREAK SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BreakStmt("");
			}
			case 228: // continue_statement = CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ContinueStmt(((String)id.value));
			}
			case 229: // continue_statement = CONTINUE.CONTINUE SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ContinueStmt("");
			}
			case 230: // return_statement = RETURN.RETURN expression_opt.e SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ReturnStmt(e);
			}
			case 231: // throw_statement = THROW.THROW expression.e SEMICOLON.SEMICOLON
			{
					final Symbol THROW = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ThrowStmt(e);
			}
			case 232: // synchronized_statement = SYNCHRONIZED.SYNCHRONIZED LPAREN.LPAREN expression.e RPAREN.RPAREN block.b
			{
					final Symbol SYNCHRONIZED = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new SynchronizedStmt(e, b);
			}
			case 233: // try_statement = TRY.TRY block.b catches.c
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					 return new TryStmt(b, c, new Opt());
			}
			case 234: // try_statement = TRY.TRY block.b finally.f
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Block f = (Block) _symbol_f.value;
					 return new TryStmt(b, new List(), new Opt(f));
			}
			case 235: // try_statement = TRY.TRY block.b catches.c finally.f
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final Block f = (Block) _symbol_f.value;
					 return new TryStmt(b, c, new Opt(f));
			}
			case 236: // catches = catch_clause.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final CatchClause c = (CatchClause) _symbol_c.value;
					 return new List().add(c);
			}
			case 237: // catches = catches.l catch_clause.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final CatchClause c = (CatchClause) _symbol_c.value;
					 return l.add(c);
			}
			case 238: // catch_clause = CATCH.CATCH LPAREN.LPAREN formal_parameter.p RPAREN.RPAREN block.b
			{
					final Symbol CATCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParameterDeclaration p = (ParameterDeclaration) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new CatchClause(p, b);
			}
			case 239: // finally = FINALLY.FINALLY block.b
			{
					final Symbol FINALLY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return b;
			}
			case 240: // assert_statement = ASSERT.ASSERT expression.e SEMICOLON.SEMICOLON
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new AssertStmt(e, new Opt());
			}
			case 241: // assert_statement = ASSERT.ASSERT expression.e COLON.COLON expression.s SEMICOLON.SEMICOLON
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Expr s = (Expr) _symbol_s.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new AssertStmt(e, new Opt(s));
			}
			case 242: // primary = primary_no_new_array.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 243: // primary = array_creation_init.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 244: // primary = array_creation_uninit.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 245: // class_literal = CLASS.CLASS
			{
					final Symbol CLASS = _symbols[offset + 1];
					 return new ClassAccess();
			}
			case 246: // subclass_body = class_body.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final List b = (List) _symbol_b.value;
					 return new Opt(new AnonymousDecl(new Modifiers(), "Anonymous", b));
			}
			case 247: // argument_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new List().add(e);
			}
			case 248: // argument_list = argument_list.l COMMA.COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return l.add(e);
			}
			case 249: // array_creation_uninit = NEW.NEW primitive_type.t dim_exprs.d
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt());
			}
			case 250: // array_creation_uninit = NEW.NEW primitive_type.t dim_exprs.d dims.e
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final List e = (List) _symbol_e.value;
					 return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt());
			}
			case 251: // array_creation_uninit = NEW.NEW class_or_interface_type.t dim_exprs.d
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt());
			}
			case 252: // array_creation_uninit = NEW.NEW class_or_interface_type.t dim_exprs.d dims.e
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final List e = (List) _symbol_e.value;
					 return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt());
			}
			case 253: // array_creation_init = NEW.NEW primitive_type.t dims.d array_initializer.i
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayInit i = (ArrayInit) _symbol_i.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i));
			}
			case 254: // array_creation_init = NEW.NEW class_or_interface_type.t dims.d array_initializer.i
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayInit i = (ArrayInit) _symbol_i.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i));
			}
			case 255: // dim_exprs = dim_expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Dims e = (Dims) _symbol_e.value;
					 return new List().add(e);
			}
			case 256: // dim_exprs = dim_exprs.l dim_expr.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final Dims e = (Dims) _symbol_e.value;
					 return l.add(e);
			}
			case 257: // dim_expr = LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new Dims(new Opt(e));
			}
			case 258: // dims = LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol RBRACK = _symbols[offset + 2];
					 Dims d = new Dims(new Opt()); d.setStart(LBRACK.getStart()); d.setEnd(RBRACK.getEnd());
                                                  return new List().add(d);
			}
			case 259: // dims = dims.l LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol RBRACK = _symbols[offset + 3];
					 Dims d = new Dims(new Opt()); d.setStart(LBRACK.getStart()); d.setEnd(RBRACK.getEnd());
                                                  return l.add(d);
			}
			case 260: // field_access = primary.p DOT.DOT simple_name.id
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_id = _symbols[offset + 3];
					final Access id = (Access) _symbol_id.value;
					 return p.qualifiesAccess(id);
			}
			case 261: // field_access = SUPER.SUPER DOT.DOT simple_name.id
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_id = _symbols[offset + 3];
					final Access id = (Access) _symbol_id.value;
					 SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return s.qualifiesAccess(id);
			}
			case 262: // field_access = name.n DOT.DOT SUPER.SUPER DOT.DOT_ simple_name.id
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol DOT_ = _symbols[offset + 4];
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					 SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return n.qualifiesAccess(s).qualifiesAccess(id);
			}
			case 263: // method_invocation = name.n LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 if(n instanceof AbstractDot) {    
                                                               AbstractDot d = (AbstractDot)n; 
                                                               ParseName pn = (ParseName)d.extractLast();
                                                               MethodAccess m = new MethodAccess(pn.getID(), l);
                                                               m.setStart(pn.getStart()); // add location information
                                                               m.setEnd(RPAREN.getEnd()); // add location information
                                                               d.replaceLast(m);
                                                               return d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               return new MethodAccess(pn.getID(), l);
                                                             }
			}
			case 264: // method_invocation = primary.p DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart()); // add location information
        m.setEnd(RPAREN.getEnd()); // add location information
        return p.qualifiesAccess(m);
			}
			case 265: // method_invocation = SUPER.SUPER DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return s.qualifiesAccess(m);
			}
			case 266: // method_invocation = name.n DOT.DOT SUPER.SUPER DOT.DOT_ IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol DOT_ = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					 SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(s).qualifiesAccess(m);
			}
			case 267: // array_access = name.n LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return n.qualifiesAccess(a);
			}
			case 268: // array_access = primary_no_new_array.p LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return p.qualifiesAccess(a);
			}
			case 269: // postfix_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 270: // postfix_expression = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 271: // postfix_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 272: // postfix_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 273: // postincrement_expression = postfix_expression.e PLUSPLUS.PLUSPLUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol PLUSPLUS = _symbols[offset + 2];
					 return new PostIncExpr(e);
			}
			case 274: // postdecrement_expression = postfix_expression.e MINUSMINUS.MINUSMINUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol MINUSMINUS = _symbols[offset + 2];
					 return new PostDecExpr(e);
			}
			case 275: // unary_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 276: // unary_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 277: // unary_expression = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 278: // unary_expression = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 279: // unary_expression = unary_expression_not_plus_minus.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 280: // preincrement_expression = PLUSPLUS.PLUSPLUS unary_expression.e
			{
					final Symbol PLUSPLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreIncExpr(e);
			}
			case 281: // predecrement_expression = MINUSMINUS.MINUSMINUS unary_expression.e
			{
					final Symbol MINUSMINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreDecExpr(e);
			}
			case 282: // unary_expression_not_plus_minus = postfix_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 283: // unary_expression_not_plus_minus = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 284: // unary_expression_not_plus_minus = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 285: // unary_expression_not_plus_minus = cast_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 286: // cast_expression = LPAREN.LPAREN primitive_type.t RPAREN.RPAREN unary_expression.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(t.addArrayDims(new List()), e);
			}
			case 287: // cast_expression = LPAREN.LPAREN primitive_type.t dims.d RPAREN.RPAREN unary_expression.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(t.addArrayDims(d), e);
			}
			case 288: // cast_expression = LPAREN.LPAREN name.n RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(n.addArrayDims(new List()), e);
			}
			case 289: // cast_expression = LPAREN.LPAREN name.n dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(n.addArrayDims(d), e);
			}
			case 290: // multiplicative_expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 291: // multiplicative_expression = multiplicative_expression.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 292: // multiplicative_expression = multiplicative_expression.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 293: // multiplicative_expression = multiplicative_expression.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 294: // additive_expression = multiplicative_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 295: // additive_expression = additive_expression.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 296: // additive_expression = additive_expression.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 297: // shift_expression = additive_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 298: // shift_expression = shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 299: // shift_expression = shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 300: // shift_expression = shift_expression.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 301: // relational_expression = shift_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 302: // relational_expression = relational_expression.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 303: // relational_expression = relational_expression.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 304: // relational_expression = relational_expression.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 305: // relational_expression = relational_expression.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 306: // relational_expression = relational_expression.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 307: // equality_expression = relational_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 308: // equality_expression = equality_expression.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 309: // equality_expression = equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 310: // and_expression = equality_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 311: // and_expression = and_expression.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 312: // exclusive_or_expression = and_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 313: // exclusive_or_expression = exclusive_or_expression.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 314: // inclusive_or_expression = exclusive_or_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 315: // inclusive_or_expression = inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 316: // conditional_and_expression = inclusive_or_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 317: // conditional_and_expression = conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 318: // conditional_or_expression = conditional_and_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 319: // conditional_or_expression = conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 320: // conditional_expression = conditional_or_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 321: // conditional_expression = conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 322: // assignment_expression = conditional_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 323: // assignment_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 324: // assignment = postfix_expression.dest EQ.EQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignSimpleExpr(dest, source);
			}
			case 325: // assignment = postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MULTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMulExpr(dest, source);
			}
			case 326: // assignment = postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol DIVEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignDivExpr(dest, source);
			}
			case 327: // assignment = postfix_expression.dest MODEQ.MODEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MODEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignModExpr(dest, source);
			}
			case 328: // assignment = postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol PLUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignPlusExpr(dest, source);
			}
			case 329: // assignment = postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MINUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMinusExpr(dest, source);
			}
			case 330: // assignment = postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol LSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignLShiftExpr(dest, source);
			}
			case 331: // assignment = postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol RSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignRShiftExpr(dest, source);
			}
			case 332: // assignment = postfix_expression.dest URSHIFTEQ.URSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol URSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignURShiftExpr(dest, source);
			}
			case 333: // assignment = postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol ANDEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignAndExpr(dest, source);
			}
			case 334: // assignment = postfix_expression.dest XOREQ.XOREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol XOREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignXorExpr(dest, source);
			}
			case 335: // assignment = postfix_expression.dest OREQ.OREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol OREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignOrExpr(dest, source);
			}
			case 336: // expression = assignment_expression.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 337: // constant_expression = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 338: // class_body_declaration = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new InstanceInitializer(new Block());
			}
			case 339: // class_body_declaration = error.error LBRACE.LBRACE
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol LBRACE = _symbols[offset + 2];
					 return new InstanceInitializer(new Block());
			}
			case 340: // block = LBRACE.LBRACE error.error RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol error = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(new List());
			}
			case 341: // switch_block = LBRACE.LBRACE error.error RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol error = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(new List());
			}
			case 342: // statement = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new EmptyStmt();
			}
			case 343: // type_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return i;
			}
			case 344: // interface_member_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 345: // class_member_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 346: // annotation_type_declaration = AT.AT INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER annotation_type_body.b
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new AnnotationDecl(new Modifiers(new List()), IDENTIFIER, b);
			}
			case 347: // annotation_type_declaration = modifiers.m AT.AT INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER annotation_type_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol AT = _symbols[offset + 2];
					final Symbol INTERFACE = _symbols[offset + 3];
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new AnnotationDecl(new Modifiers(m), IDENTIFIER, b);
			}
			case 348: // annotation_type_body = LBRACE.LBRACE annotation_type_element_declarations_opt.i RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return i;
			}
			case 349: // annotation_type_element_declarations = annotation_type_element_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 350: // annotation_type_element_declarations = annotation_type_element_declarations.l annotation_type_element_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 351: // annotation_type_element_declaration = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_default_value = _symbols[offset + 5];
					final Opt default_value = (Opt) _symbol_default_value.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new AnnotationMethodDecl(new Modifiers(new List()), t, IDENTIFIER, new List(), new List(), new Opt(), default_value);
			}
			case 352: // annotation_type_element_declaration = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_default_value = _symbols[offset + 6];
					final Opt default_value = (Opt) _symbol_default_value.value;
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new AnnotationMethodDecl(new Modifiers(m), t, IDENTIFIER, new List(), new List(), new Opt(), default_value);
			}
			case 354: // annotation_type_element_declaration = class_declaration.class_declaration
			{
					final Symbol _symbol_class_declaration = _symbols[offset + 1];
					final ClassDecl class_declaration = (ClassDecl) _symbol_class_declaration.value;
					 return new MemberClassDecl(class_declaration);
			}
			case 355: // annotation_type_element_declaration = interface_declaration.interface_declaration
			{
					final Symbol _symbol_interface_declaration = _symbols[offset + 1];
					final InterfaceDecl interface_declaration = (InterfaceDecl) _symbol_interface_declaration.value;
					 return new MemberInterfaceDecl(interface_declaration);
			}
			case 356: // annotation_type_element_declaration = enum_declaration.enum_declaration
			{
					final Symbol _symbol_enum_declaration = _symbols[offset + 1];
					final EnumDecl enum_declaration = (EnumDecl) _symbol_enum_declaration.value;
					 return new MemberClassDecl(enum_declaration);
			}
			case 357: // annotation_type_element_declaration = annotation_type_declaration.annotation_type_declaration
			{
					final Symbol _symbol_annotation_type_declaration = _symbols[offset + 1];
					final AnnotationDecl annotation_type_declaration = (AnnotationDecl) _symbol_annotation_type_declaration.value;
					 return new MemberInterfaceDecl(annotation_type_declaration);
			}
			case 358: // annotation_type_element_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new StaticInitializer(new Block());
			}
			case 359: // default_value = DEFAULT.DEFAULT element_value.element_value
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol _symbol_element_value = _symbols[offset + 2];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return element_value;
			}
			case 364: // normal_annotation = AT.AT type.type LPAREN.LPAREN element_value_pairs_opt.element_value_pairs RPAREN.RPAREN
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_element_value_pairs = _symbols[offset + 4];
					final List element_value_pairs = (List) _symbol_element_value_pairs.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new Annotation("annotation", type, element_value_pairs);
			}
			case 365: // element_value_pairs = element_value_pair.element_value_pair
			{
					final Symbol _symbol_element_value_pair = _symbols[offset + 1];
					final ElementValuePair element_value_pair = (ElementValuePair) _symbol_element_value_pair.value;
					 return new List().add(element_value_pair);
			}
			case 366: // element_value_pairs = element_value_pairs.element_value_pairs COMMA.COMMA element_value_pair.element_value_pair
			{
					final Symbol _symbol_element_value_pairs = _symbols[offset + 1];
					final List element_value_pairs = (List) _symbol_element_value_pairs.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_element_value_pair = _symbols[offset + 3];
					final ElementValuePair element_value_pair = (ElementValuePair) _symbol_element_value_pair.value;
					 return element_value_pairs.add(element_value_pair);
			}
			case 367: // element_value_pair = IDENTIFIER.IDENTIFIER EQ.EQ element_value.element_value
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_element_value = _symbols[offset + 3];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return new ElementValuePair(IDENTIFIER, element_value);
			}
			case 368: // element_value = conditional_expression.conditional_expression
			{
					final Symbol _symbol_conditional_expression = _symbols[offset + 1];
					final Expr conditional_expression = (Expr) _symbol_conditional_expression.value;
					 return new ElementConstantValue(conditional_expression);
			}
			case 369: // element_value = annotation.annotation
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return new ElementAnnotationValue(annotation);
			}
			case 370: // element_value = element_value_array_initializer.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ElementArrayValue e = (ElementArrayValue) _symbol_e.value;
					 return e;
			}
			case 371: // element_value_array_initializer = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ElementArrayValue(new List());
			}
			case 372: // element_value_array_initializer = LBRACE.LBRACE element_values.element_values RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_element_values = _symbols[offset + 2];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ElementArrayValue(element_values);
			}
			case 373: // element_value_array_initializer = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ElementArrayValue(new List());
			}
			case 374: // element_value_array_initializer = LBRACE.LBRACE element_values.element_values COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_element_values = _symbols[offset + 2];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ElementArrayValue(element_values);
			}
			case 375: // element_values = element_value.element_value
			{
					final Symbol _symbol_element_value = _symbols[offset + 1];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return new List().add(element_value);
			}
			case 376: // element_values = element_values.element_values COMMA.COMMA element_value.element_value
			{
					final Symbol _symbol_element_values = _symbols[offset + 1];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_element_value = _symbols[offset + 3];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return element_values.add(element_value);
			}
			case 377: // marker_annotation = AT.AT type.type
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					 return new Annotation("annotation", type, new List());
			}
			case 378: // single_element_annotation = AT.AT type.type LPAREN.LPAREN element_value.element_value RPAREN.RPAREN
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_element_value = _symbols[offset + 4];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new Annotation("annotation", type, new List().add(new ElementValuePair("value", element_value)));
			}
			case 379: // compilation_unit = modifiers.a package_declaration.p
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					 return new AnnotatedCompilationUnit(p.getID(), new List(), new List(), new Modifiers(a));
			}
			case 380: // compilation_unit = modifiers.a package_declaration.p import_declarations.i
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					 return new AnnotatedCompilationUnit(p.getID(), i, new List(), new Modifiers(a));
			}
			case 381: // compilation_unit = modifiers.a package_declaration.p type_declarations.t
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final List t = (List) _symbol_t.value;
					 return new AnnotatedCompilationUnit(p.getID(), new List(), t, new Modifiers(a));
			}
			case 382: // compilation_unit = modifiers.a package_declaration.p import_declarations.i type_declarations.t
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final List t = (List) _symbol_t.value;
					 return new AnnotatedCompilationUnit(p.getID(), i, t, new Modifiers(a));
			}
			case 383: // statement = enhanced_for_statement.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Stmt f = (Stmt) _symbol_f.value;
					 return f;
			}
			case 384: // statement_no_short_if = enhanced_for_statement_no_short_if.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Stmt f = (Stmt) _symbol_f.value;
					 return f;
			}
			case 385: // enhanced_for_statement = FOR.FOR LPAREN.LPAREN enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final VariableDeclaration p = (VariableDeclaration) _symbol_p.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new EnhancedForStmt(p, e, s);
			}
			case 386: // enhanced_for_statement_no_short_if = FOR.FOR LPAREN.LPAREN enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final VariableDeclaration p = (VariableDeclaration) _symbol_p.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new EnhancedForStmt(p, e, s);
			}
			case 387: // enhanced_for_parameter = type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new VariableDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, new Opt());
			}
			case 388: // enhanced_for_parameter = modifiers.m type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new VariableDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, new Opt());
			}
			case 389: // type_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return i;
			}
			case 390: // interface_member_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return new MemberClassDecl(i);
			}
			case 391: // class_member_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return new MemberClassDecl(i);
			}
			case 392: // enum_declaration = ENUM.ENUM IDENTIFIER.id enum_body.b
			{
					final Symbol ENUM = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(new List()), ((String)id.value), new List(), b);
			}
			case 393: // enum_declaration = modifiers.m ENUM.ENUM IDENTIFIER.id enum_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol ENUM = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(m), ((String)id.value), new List(), b);
			}
			case 394: // enum_declaration = ENUM.ENUM IDENTIFIER.id interfaces.i enum_body.b
			{
					final Symbol ENUM = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(new List()), ((String)id.value), i, b);
			}
			case 395: // enum_declaration = modifiers.m ENUM.ENUM IDENTIFIER.id interfaces.i enum_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol ENUM = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(m), ((String)id.value), i, b);
			}
			case 396: // enum_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new List();
			}
			case 397: // enum_body = LBRACE.LBRACE enum_constants.enum_constants RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_constants = _symbols[offset + 2];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return enum_constants;
			}
			case 398: // enum_body = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new List();
			}
			case 399: // enum_body = LBRACE.LBRACE enum_constants.enum_constants COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_constants = _symbols[offset + 2];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return enum_constants;
			}
			case 400: // enum_body = LBRACE.LBRACE enum_body_declarations.enum_body_declarations RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_body_declarations = _symbols[offset + 2];
					final List enum_body_declarations = (List) _symbol_enum_body_declarations.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return enum_body_declarations;
			}
			case 401: // enum_body = LBRACE.LBRACE enum_constants.c enum_body_declarations.d RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c;
			}
			case 402: // enum_body = LBRACE.LBRACE COMMA.COMMA enum_body_declarations.enum_body_declarations RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_body_declarations = _symbols[offset + 3];
					final List enum_body_declarations = (List) _symbol_enum_body_declarations.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return enum_body_declarations;
			}
			case 403: // enum_body = LBRACE.LBRACE enum_constants.c COMMA.COMMA enum_body_declarations.d RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					final Symbol RBRACE = _symbols[offset + 5];
					 for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c;
			}
			case 404: // enum_constants = enum_constant.enum_constant
			{
					final Symbol _symbol_enum_constant = _symbols[offset + 1];
					final BodyDecl enum_constant = (BodyDecl) _symbol_enum_constant.value;
					 return new List().add(enum_constant);
			}
			case 405: // enum_constants = enum_constants.enum_constants COMMA.COMMA enum_constant.enum_constant
			{
					final Symbol _symbol_enum_constants = _symbols[offset + 1];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_constant = _symbols[offset + 3];
					final BodyDecl enum_constant = (BodyDecl) _symbol_enum_constant.value;
					 return enum_constants.add(enum_constant);
			}
			case 406: // enum_constant = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), new List());
			}
			case 407: // enum_constant = annotations.annotations IDENTIFIER.id
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), new List());
			}
			case 408: // enum_constant = IDENTIFIER.id arguments.arguments
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 2];
					final List arguments = (List) _symbol_arguments.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, new List());
			}
			case 409: // enum_constant = annotations.annotations IDENTIFIER.id arguments.arguments
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final List arguments = (List) _symbol_arguments.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, new List());
			}
			case 410: // enum_constant = IDENTIFIER.id class_body.class_body
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_class_body = _symbols[offset + 2];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), class_body);
			}
			case 411: // enum_constant = annotations.annotations IDENTIFIER.id class_body.class_body
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_class_body = _symbols[offset + 3];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), class_body);
			}
			case 412: // enum_constant = IDENTIFIER.id arguments.arguments class_body.class_body
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 2];
					final List arguments = (List) _symbol_arguments.value;
					final Symbol _symbol_class_body = _symbols[offset + 3];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, class_body);
			}
			case 413: // enum_constant = annotations.annotations IDENTIFIER.id arguments.arguments class_body.class_body
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final List arguments = (List) _symbol_arguments.value;
					final Symbol _symbol_class_body = _symbols[offset + 4];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, class_body);
			}
			case 414: // arguments = LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_argument_list = _symbols[offset + 2];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return argument_list;
			}
			case 415: // annotations = annotation.annotation
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return new List().add(annotation);
			}
			case 416: // annotations = annotations.annotations annotation.annotation
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol _symbol_annotation = _symbols[offset + 2];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return annotations.add(annotation);
			}
			case 417: // enum_body_declarations = SEMICOLON.SEMICOLON class_body_declarations_opt.class_body_declarations
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					final Symbol _symbol_class_body_declarations = _symbols[offset + 2];
					final List class_body_declarations = (List) _symbol_class_body_declarations.value;
					 return class_body_declarations;
			}
			case 418: // explicit_constructor_invocation = type_arguments.a THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol THIS = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ExprStmt(new ParConstructorAccess("this", l, a));
			}
			case 419: // explicit_constructor_invocation = type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ExprStmt(new ParSuperConstructorAccess("super", l, a));
			}
			case 420: // explicit_constructor_invocation = primary.p DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ExprStmt(p.qualifiesAccess(new ParSuperConstructorAccess("super", l, a)));
			}
			case 421: // explicit_constructor_invocation = name.n DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ExprStmt(n.qualifiesAccess(new ParSuperConstructorAccess("super", l, a)));
			}
			case 422: // method_invocation = primary.p DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return p.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 423: // method_invocation = name.n DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return n.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 424: // method_invocation = SUPER.SUPER DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return new SuperAccess("super").qualifiesAccess(
		                    new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 425: // method_invocation = name.n DOT.d1 SUPER.SUPER DOT.d2 type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol d1 = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol d2 = _symbols[offset + 4];
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 6];
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					 return n.qualifiesAccess(new SuperAccess("super")).qualifiesAccess(
                            new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 426: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 427: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 428: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_d = _symbols[offset + 8];
					final List d = (List) _symbol_d.value;
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 429: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_d = _symbols[offset + 9];
					final List d = (List) _symbol_d.value;
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 430: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 431: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_tl = _symbols[offset + 9];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 432: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_d = _symbols[offset + 8];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 9];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 433: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_d = _symbols[offset + 9];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 10];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 434: // method_header = LT.LT type_parameter_list_1.l VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws_opt.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol VOID = _symbols[offset + 3];
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 435: // method_header = modifiers.m LT.LT type_parameter_list_1.l VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws_opt.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol VOID = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_tl = _symbols[offset + 9];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 436: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol RBRACE = _symbols[offset + 9];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), new Block(new List()), l);
			}
			case 437: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol RBRACE = _symbols[offset + 10];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), new Block(new List()), l);
			}
			case 438: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol _symbol_c = _symbols[offset + 9];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 10];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), new Block(new List()), l);
			}
			case 439: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol _symbol_c = _symbols[offset + 10];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 11];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), new Block(new List()), l);
			}
			case 440: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.bl RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol _symbol_bl = _symbols[offset + 9];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 10];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), new Block(bl), l);
			}
			case 441: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.bl RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol _symbol_bl = _symbols[offset + 10];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 11];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), new Block(bl), l);
			}
			case 442: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.bl RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol _symbol_c = _symbols[offset + 9];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_bl = _symbols[offset + 10];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 11];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), new Block(bl), l);
			}
			case 443: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.bl RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol _symbol_c = _symbols[offset + 10];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_bl = _symbols[offset + 11];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 12];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), new Block(bl), l);
			}
			case 444: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), new List(), b, p);
			}
			case 445: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), new List(), b, p);
			}
			case 446: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, s, new List(), b, p);
			}
			case 447: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, new List(), b, p);
			}
			case 448: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), i, b, p);
			}
			case 449: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), i, b, p);
			}
			case 450: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, s, i, b, p);
			}
			case 451: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 6];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 7];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, i, b, p);
			}
			case 452: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(new List()), IDENTIFIER, new List(), b, p);
			}
			case 453: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, new List(), b, p);
			}
			case 454: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p extends_interfaces.i interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(new List()), IDENTIFIER, i, b, p);
			}
			case 455: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p extends_interfaces.i interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b, p);
			}
			case 456: // class_or_interface = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 457: // class_or_interface = class_or_interface.n LT.LT type_argument_list_1.l DOT.DOT name.end
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol _symbol_end = _symbols[offset + 5];
					final Access end = (Access) _symbol_end.value;
					 return new ParTypeAccess(n, l).qualifiesAccess(end);
			}
			case 458: // class_or_interface_type = class_or_interface.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 459: // class_or_interface_type = class_or_interface.n LT.LT type_argument_list_1.l
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(n, l);
			}
			case 460: // array_type = class_or_interface.t LT.LT type_argument_list_1.l DOT.DOT name.n dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol _symbol_n = _symbols[offset + 5];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					 return new ParTypeAccess(t, l).qualifiesAccess(n).addArrayDims(d);
			}
			case 461: // array_type = class_or_interface.t LT.LT type_argument_list_1.l dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new ParTypeAccess(t, l).addArrayDims(d);
			}
			case 462: // type_arguments = LT.LT type_argument_list_1.l
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 463: // wildcard = QUESTION.QUESTION
			{
					final Symbol QUESTION = _symbols[offset + 1];
					 return new Wildcard();
			}
			case 464: // wildcard = QUESTION.QUESTION EXTENDS.EXTENDS reference_type.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 465: // wildcard = QUESTION.QUESTION SUPER.SUPER reference_type.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 466: // wildcard_1 = QUESTION.QUESTION GT.GT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol GT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 467: // wildcard_1 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_1.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 468: // wildcard_1 = QUESTION.QUESTION SUPER.SUPER reference_type_1.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 469: // wildcard_2 = QUESTION.QUESTION RSHIFT.RSHIFT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol RSHIFT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 470: // wildcard_2 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_2.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 471: // wildcard_2 = QUESTION.QUESTION SUPER.SUPER reference_type_2.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 472: // wildcard_3 = QUESTION.QUESTION URSHIFT.URSHIFT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol URSHIFT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 473: // wildcard_3 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_3.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 474: // wildcard_3 = QUESTION.QUESTION SUPER.SUPER reference_type_3.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 475: // class_instance_creation_expression = NEW.NEW class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_b = _symbols[offset + 6];
					final Opt b = (Opt) _symbol_b.value;
					 return new ClassInstanceExpr(t, l, b);
			}
			case 476: // class_instance_creation_expression = NEW.NEW type_arguments.a class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_b = _symbols[offset + 7];
					final Opt b = (Opt) _symbol_b.value;
					 return new ParClassInstanceExpr(t, l, b, a);
			}
			case 477: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_b = _symbols[offset + 8];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 478: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW simple_name.id type_arguments.a LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 479: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca));
			}
			case 480: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_ta = _symbols[offset + 6];
					final List ta = (List) _symbol_ta.value;
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					final Symbol _symbol_b = _symbols[offset + 10];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca));
			}
			case 481: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_b = _symbols[offset + 8];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 482: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW simple_name.id type_arguments.a LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 483: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca));
			}
			case 484: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_ta = _symbols[offset + 6];
					final List ta = (List) _symbol_ta.value;
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					final Symbol _symbol_b = _symbols[offset + 10];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca));
			}
			case 485: // type_argument_list = type_argument.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 486: // type_argument_list = type_argument_list.l COMMA.COMMA type_argument.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 487: // type_argument_list_1 = type_argument_1.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 488: // type_argument_list_1 = type_argument_list.l COMMA.COMMA type_argument_1.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 489: // type_argument_list_2 = type_argument_2.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 490: // type_argument_list_2 = type_argument_list.l COMMA.COMMA type_argument_2.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 491: // type_argument_list_3 = type_argument_3.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 492: // type_argument_list_3 = type_argument_list.l COMMA.COMMA type_argument_3.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 493: // type_argument = reference_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 494: // type_argument = wildcard.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 495: // type_argument_1 = reference_type_1.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 496: // type_argument_1 = wildcard_1.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 497: // type_argument_2 = reference_type_2.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 498: // type_argument_2 = wildcard_2.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 499: // type_argument_3 = reference_type_3.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 500: // type_argument_3 = wildcard_3.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 501: // reference_type_1 = reference_type.t GT.GT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol GT = _symbols[offset + 2];
					 return t;
			}
			case 502: // reference_type_1 = class_or_interface.t LT.LT type_argument_list_2.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 503: // reference_type_2 = reference_type.t RSHIFT.RSHIFT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					 return t;
			}
			case 504: // reference_type_2 = class_or_interface.t LT.LT type_argument_list_3.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 505: // reference_type_3 = reference_type.t URSHIFT.URSHIFT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					 return t;
			}
			case 506: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).addArrayDims(new List()), e);
			}
			case 507: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_e = _symbols[offset + 7];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).addArrayDims(d), e);
			}
			case 508: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 5];
					final Symbol _symbol_t = _symbols[offset + 6];
					final Access t = (Access) _symbol_t.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_e = _symbols[offset + 8];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), e);
			}
			case 509: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 5];
					final Symbol _symbol_t = _symbols[offset + 6];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_e = _symbols[offset + 9];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d), e);
			}
			case 510: // type_parameters = LT.LT type_parameter_list_1.l
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 511: // type_parameter_list = type_parameter_list.l COMMA.COMMA type_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return l.add(p);
			}
			case 512: // type_parameter_list = type_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return new List().add(p);
			}
			case 513: // type_parameter_list_1 = type_parameter_1.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return new List().add(p);
			}
			case 514: // type_parameter_list_1 = type_parameter_list.l COMMA.COMMA type_parameter_1.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return l.add(p);
			}
			case 515: // type_parameter = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List());
			}
			case 516: // type_parameter = IDENTIFIER.IDENTIFIER type_bound.l
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l);
			}
			case 517: // type_parameter_1 = IDENTIFIER.IDENTIFIER GT.GT
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol GT = _symbols[offset + 2];
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List());
			}
			case 518: // type_parameter_1 = IDENTIFIER.IDENTIFIER type_bound_1.l
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l);
			}
			case 519: // type_bound = EXTENDS.EXTENDS reference_type.t
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 520: // type_bound = EXTENDS.EXTENDS reference_type.t additional_bound_list.l
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 l.insertChild(t,0); return l;
			}
			case 521: // type_bound_1 = EXTENDS.EXTENDS reference_type_1.t
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 522: // type_bound_1 = EXTENDS.EXTENDS reference_type.t additional_bound_list_1.l
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 l.insertChild(t,0); return l;
			}
			case 523: // additional_bound_list = additional_bound.b additional_bound_list.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 l.insertChild(b,0); return l;
			}
			case 524: // additional_bound_list = additional_bound.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					 return new List().add(b);
			}
			case 525: // additional_bound_list_1 = additional_bound.b additional_bound_list_1.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 l.insertChild(b,0); return l;
			}
			case 526: // additional_bound_list_1 = additional_bound_1.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					 return new List().add(b);
			}
			case 527: // additional_bound = AND.AND interface_type.t
			{
					final Symbol AND = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 528: // additional_bound_1 = AND.AND reference_type_1.t
			{
					final Symbol AND = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 529: // import_declaration = single_static_import_declaration.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ImportDecl s = (ImportDecl) _symbol_s.value;
					 return s;
			}
			case 530: // import_declaration = static_import_on_demand_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ImportDecl t = (ImportDecl) _symbol_t.value;
					 return t;
			}
			case 531: // single_static_import_declaration = IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol STATIC = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new SingleStaticImportDecl(n, IDENTIFIER);
			}
			case 532: // static_import_on_demand_declaration = IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol STATIC = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol MULT = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new StaticImportOnDemandDecl(n);
			}
			case 533: // formal_parameter = type.t ELLIPSIS.ELLIPSIS IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol ELLIPSIS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new VariableArityParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER);
			}
			case 534: // formal_parameter = modifiers.m type.t ELLIPSIS.ELLIPSIS IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol ELLIPSIS = _symbols[offset + 3];
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					 return new VariableArityParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER);
			}
			case 535: // primary_no_new_array = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					 return l;
			}
			case 536: // primary_no_new_array = primitive_type.n DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(new List()).qualifiesAccess(c);
			}
			case 537: // primary_no_new_array = primitive_type.n dims.d DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(d).qualifiesAccess(c);
			}
			case 538: // primary_no_new_array = name.n DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(new List()).qualifiesAccess(c);
			}
			case 539: // primary_no_new_array = name.n dims.d DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(d).qualifiesAccess(c);
			}
			case 540: // primary_no_new_array = VOID.VOID DOT.DOT class_literal.c
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 PrimitiveTypeAccess v = new PrimitiveTypeAccess("void");
                                                  v.setStart(VOID.getStart());
                                                  v.setEnd(VOID.getEnd());
                                                  return v.qualifiesAccess(c);
			}
			case 541: // primary_no_new_array = THIS.THIS
			{
					final Symbol THIS = _symbols[offset + 1];
					 return new ThisAccess("this");
			}
			case 542: // primary_no_new_array = name.n DOT.DOT THIS.THIS
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol THIS = _symbols[offset + 3];
					 ThisAccess t = new ThisAccess("this");
                                                  t.setStart(THIS.getStart()); t.setEnd(THIS.getEnd());
                                                  return n.qualifiesAccess(t);
			}
			case 543: // primary_no_new_array = LPAREN.LPAREN expression_nn.e RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ParExpr(e);
			}
			case 544: // primary_no_new_array = LPAREN.LPAREN name.n RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ParExpr(n);
			}
			case 545: // primary_no_new_array = class_instance_creation_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 546: // primary_no_new_array = field_access.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Access f = (Access) _symbol_f.value;
					 return f;
			}
			case 547: // primary_no_new_array = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Access m = (Access) _symbol_m.value;
					 return m;
			}
			case 548: // primary_no_new_array = array_access.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return a;
			}
			case 549: // postfix_expression_nn = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 550: // postfix_expression_nn = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 551: // postfix_expression_nn = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 552: // unary_expression_nn = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 553: // unary_expression_nn = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 554: // unary_expression_nn = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 555: // unary_expression_nn = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 556: // unary_expression_nn = unary_expression_not_plus_minus_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 557: // unary_expression_not_plus_minus_nn = postfix_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 558: // unary_expression_not_plus_minus_nn = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 559: // unary_expression_not_plus_minus_nn = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 560: // unary_expression_not_plus_minus_nn = cast_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 561: // multiplicative_expression_nn = unary_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 562: // multiplicative_expression_nn = name.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 563: // multiplicative_expression_nn = multiplicative_expression_nn.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 564: // multiplicative_expression_nn = name.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 565: // multiplicative_expression_nn = multiplicative_expression_nn.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 566: // multiplicative_expression_nn = name.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 567: // multiplicative_expression_nn = multiplicative_expression_nn.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 568: // additive_expression_nn = multiplicative_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 569: // additive_expression_nn = name.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 570: // additive_expression_nn = additive_expression_nn.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 571: // additive_expression_nn = name.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 572: // additive_expression_nn = additive_expression_nn.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 573: // shift_expression_nn = additive_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 574: // shift_expression_nn = name.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 575: // shift_expression_nn = shift_expression_nn.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 576: // shift_expression_nn = name.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 577: // shift_expression_nn = shift_expression_nn.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 578: // shift_expression_nn = name.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 579: // shift_expression_nn = shift_expression_nn.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 580: // relational_expression_nn = shift_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 581: // relational_expression_nn = name.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 582: // relational_expression_nn = shift_expression_nn.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 583: // relational_expression_nn = name.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 584: // relational_expression_nn = shift_expression_nn.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 585: // relational_expression_nn = name.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 586: // relational_expression_nn = relational_expression_nn.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 587: // relational_expression_nn = name.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 588: // relational_expression_nn = relational_expression_nn.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 589: // relational_expression_nn = name.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Access e = (Access) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 590: // relational_expression_nn = relational_expression_nn.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 591: // equality_expression_nn = relational_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 592: // equality_expression_nn = name.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 593: // equality_expression_nn = equality_expression_nn.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 594: // equality_expression_nn = name.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 595: // equality_expression_nn = equality_expression_nn.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 596: // and_expression_nn = equality_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 597: // and_expression_nn = name.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 598: // and_expression_nn = and_expression_nn.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 599: // exclusive_or_expression_nn = and_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 600: // exclusive_or_expression_nn = name.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 601: // exclusive_or_expression_nn = exclusive_or_expression_nn.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 602: // inclusive_or_expression_nn = exclusive_or_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 603: // inclusive_or_expression_nn = name.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 604: // inclusive_or_expression_nn = inclusive_or_expression_nn.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 605: // conditional_and_expression_nn = inclusive_or_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 606: // conditional_and_expression_nn = name.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 607: // conditional_and_expression_nn = conditional_and_expression_nn.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 608: // conditional_or_expression_nn = conditional_and_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 609: // conditional_or_expression_nn = name.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 610: // conditional_or_expression_nn = conditional_or_expression_nn.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 611: // conditional_expression_nn = conditional_or_expression_nn.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 612: // conditional_expression_nn = name.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Access c = (Access) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 613: // conditional_expression_nn = conditional_or_expression_nn.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 614: // assignment_expression_nn = conditional_expression_nn.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 615: // assignment_expression_nn = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 617: // compilation_unit = package_declaration.p pt_declaration_list.pt
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_pt = _symbols[offset + 2];
					final List pt = (List) _symbol_pt.value;
					 return new PTCompilationUnit(p.getID(), new List(), new List<TypeDecl>(), pt);
			}
			case 618: // compilation_unit = package_declaration.p import_declarations.i pt_declaration_list.pt
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_pt = _symbols[offset + 3];
					final List pt = (List) _symbol_pt.value;
					 return new PTCompilationUnit(p.getID(), i, new List<TypeDecl>(), pt);
			}
			case 619: // compilation_unit = pt_declaration_list.pt
			{
					final Symbol _symbol_pt = _symbols[offset + 1];
					final List pt = (List) _symbol_pt.value;
					 return new PTCompilationUnit("", new List(), new List<TypeDecl>(), pt);
			}
			case 620: // compilation_unit = import_declarations.i pt_declaration_list.pt
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_pt = _symbols[offset + 2];
					final List pt = (List) _symbol_pt.value;
					 return new PTCompilationUnit("", i, new List<TypeDecl>(), pt);
			}
			case 621: // pt_declaration = pt_template.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final PTDecl t = (PTDecl) _symbol_t.value;
					 return t;
			}
			case 622: // pt_declaration = pt_package.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final PTDecl p = (PTDecl) _symbol_p.value;
					 return p;
			}
			case 623: // pt_template = TEMPLATE.TEMPLATE IDENTIFIER.IDENTIFIER LBRACE.LBRACE pt_inst_decl_opt_list.pt_inst pt_simple_declaration_opt_list.pt_class RBRACE.RBRACE
			{
					final Symbol TEMPLATE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LBRACE = _symbols[offset + 3];
					final Symbol _symbol_pt_inst = _symbols[offset + 4];
					final List pt_inst = (List) _symbol_pt_inst.value;
					final Symbol _symbol_pt_class = _symbols[offset + 5];
					final List pt_class = (List) _symbol_pt_class.value;
					final Symbol RBRACE = _symbols[offset + 6];
					 return new PTTemplate(IDENTIFIER, pt_inst, pt_class);
			}
			case 624: // pt_package = PACKAGE.PACKAGE IDENTIFIER.IDENTIFIER LBRACE.LBRACE pt_inst_decl_list.pt_inst pt_simple_declaration_opt_list.pt_class RBRACE.RBRACE
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LBRACE = _symbols[offset + 3];
					final Symbol _symbol_pt_inst = _symbols[offset + 4];
					final List pt_inst = (List) _symbol_pt_inst.value;
					final Symbol _symbol_pt_class = _symbols[offset + 5];
					final List pt_class = (List) _symbol_pt_class.value;
					final Symbol RBRACE = _symbols[offset + 6];
					 return new PTPackage(IDENTIFIER, pt_inst, pt_class);
			}
			case 625: // pt_simple_declaration = class_declaration.cd
			{
					final Symbol _symbol_cd = _symbols[offset + 1];
					final ClassDecl cd = (ClassDecl) _symbol_cd.value;
					 return new PTClassDecl(cd);
			}
			case 626: // pt_simple_declaration = adds_class.ac
			{
					final Symbol _symbol_ac = _symbols[offset + 1];
					final ClassDecl ac = (ClassDecl) _symbol_ac.value;
					 return new PTClassAddsDecl(ac);
			}
			case 627: // pt_inst_decl = INST.INST IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol INST = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new PTInstDecl(IDENTIFIER, new List());
			}
			case 628: // pt_inst_decl = INST.INST IDENTIFIER.IDENTIFIER WITH.WITH dummy_class_list.dcl SEMICOLON.SEMICOLON
			{
					final Symbol INST = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol WITH = _symbols[offset + 3];
					final Symbol _symbol_dcl = _symbols[offset + 4];
					final List dcl = (List) _symbol_dcl.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new PTInstDecl(IDENTIFIER, dcl);
			}
			case 629: // dummy_class_list = dummy_class_list.dcl COMMA.COMMA dummy_inst_tuple.t
			{
					final Symbol _symbol_dcl = _symbols[offset + 1];
					final List dcl = (List) _symbol_dcl.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final PTDummyClass t = (PTDummyClass) _symbol_t.value;
					 return dcl.add(t);
			}
			case 630: // dummy_class_list = dummy_inst_tuple.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final PTDummyClass t = (PTDummyClass) _symbol_t.value;
					 return new List().add(t);
			}
			case 631: // dummy_inst_tuple = IDENTIFIER.a RIGHTARROW.RIGHTARROW IDENTIFIER.b dummy_inst_tuple_rename_list_opt.l
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol RIGHTARROW = _symbols[offset + 2];
					final Symbol b = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					 return new PTDummyClass(((String)a.value),((String)b.value),l);
			}
			case 632: // dummy_inst_tuple_rename_list_opt = LPAREN.LPAREN dummy_inst_tuple_rename_list.l RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return l;
			}
			case 633: // dummy_inst_tuple_rename_list_opt = 
			{
					 return new List();
			}
			case 634: // dummy_inst_tuple_rename_list = dummy_inst_tuple_rename_list.l COMMA.COMMA definition_renaming.dr
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_dr = _symbols[offset + 3];
					final PTDummyRename dr = (PTDummyRename) _symbol_dr.value;
					 return l.add(dr);
			}
			case 635: // dummy_inst_tuple_rename_list = definition_renaming.dr
			{
					final Symbol _symbol_dr = _symbols[offset + 1];
					final PTDummyRename dr = (PTDummyRename) _symbol_dr.value;
					 return new List().add(dr);
			}
			case 636: // def_opt_rename_params = def_rename_params_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 637: // def_opt_rename_params = 
			{
					 return new List();
			}
			case 638: // def_rename_params_list = def_rename_params_list.l COMMA.COMMA type.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return l.add(t);
			}
			case 639: // def_rename_params_list = type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 640: // definition_renaming = IDENTIFIER.a SIMPLERIGHTARROW.SIMPLERIGHTARROW IDENTIFIER.b
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol SIMPLERIGHTARROW = _symbols[offset + 2];
					final Symbol b = _symbols[offset + 3];
					 return new PTFieldRename(((String)a.value),((String)b.value));
			}
			case 641: // definition_renaming = IDENTIFIER.a ASTERISK_PAR.ASTERISK_PAR SIMPLERIGHTARROW.SIMPLERIGHTARROW IDENTIFIER.b
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol ASTERISK_PAR = _symbols[offset + 2];
					final Symbol SIMPLERIGHTARROW = _symbols[offset + 3];
					final Symbol b = _symbols[offset + 4];
					 return new PTMethodRenameAll(((String)a.value),((String)b.value));
			}
			case 642: // definition_renaming = IDENTIFIER.a LPAREN.LPAREN def_opt_rename_params.pl RPAREN.RPAREN SIMPLERIGHTARROW.SIMPLERIGHTARROW IDENTIFIER.b
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SIMPLERIGHTARROW = _symbols[offset + 5];
					final Symbol b = _symbols[offset + 6];
					 return new PTMethodRename(((String)a.value),((String)b.value),pl);
			}
			case 643: // adds_class = CLASS.CLASS IDENTIFIER.IDENTIFIER ADDS.ADDS class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol ADDS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(), IDENTIFIER, new Opt(), new List(), b);
			}
			case 644: // method_invocation = explicit_merged_method_invocation.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Access e = (Access) _symbol_e.value;
					 return e;
			}
			case 645: // method_invocation = explicit_merged_constructor_invocation.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Access e = (Access) _symbol_e.value;
					 return e;
			}
			case 646: // explicit_merged_method_invocation = SUPER.SUPER LBRACK.LBRACK IDENTIFIER.superClassName RBRACK.RBRACK merged_method_name.methodName LPAREN.LPAREN argument_list_opt.args RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol superClassName = _symbols[offset + 3];
					final Symbol RBRACK = _symbols[offset + 4];
					final Symbol _symbol_methodName = _symbols[offset + 5];
					final String methodName = (String) _symbol_methodName.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_args = _symbols[offset + 7];
					final List args = (List) _symbol_args.value;
					final Symbol RPAREN = _symbols[offset + 8];
					 PTMergedMethodAccess m = new PTMergedMethodAccess(methodName, args, ((String)superClassName.value));
        m.setStart(SUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m;
			}
			case 647: // explicit_merged_constructor_invocation = SUPER.SUPER LBRACK.LBRACK IDENTIFIER.superClassName RBRACK.RBRACK LPAREN.LPAREN argument_list_opt.args RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol superClassName = _symbols[offset + 3];
					final Symbol RBRACK = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_args = _symbols[offset + 6];
					final List args = (List) _symbol_args.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 String mName = "super" + ((String)superClassName.value);
        PTMergedConstructorAccess m = new PTMergedConstructorAccess(mName, args, ((String)superClassName.value));
        m.setStart(SUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m;
			}
			case 648: // merged_method_name = DOT.DOT IDENTIFIER.IDENTIFIER
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					 return IDENTIFIER;
			}
			case 649: // annotation_type_element_declarations_opt = 
			{
					 return new List();
			}
			case 650: // annotation_type_element_declarations_opt = annotation_type_element_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 651: // default_value_opt = 
			{
					 return new Opt();
			}
			case 652: // default_value_opt = default_value.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElementValue n = (ElementValue) _symbol_n.value;
					 return new Opt(n);
			}
			case 653: // block_statements_opt = 
			{
					 return new List();
			}
			case 654: // block_statements_opt = block_statements.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 655: // expression_opt = 
			{
					 return new Opt();
			}
			case 656: // expression_opt = expression.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					 return new Opt(n);
			}
			case 657: // interface_member_declarations_opt = 
			{
					 return new List();
			}
			case 658: // interface_member_declarations_opt = interface_member_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 659: // argument_list_opt = 
			{
					 return new List();
			}
			case 660: // argument_list_opt = argument_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 661: // subclass_body_opt = 
			{
					 return new Opt();
			}
			case 662: // subclass_body_opt = subclass_body.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Opt n = (Opt) _symbol_n.value;
					 return n;
			}
			case 663: // dims_opt = 
			{
					 return new List();
			}
			case 664: // dims_opt = dims.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 665: // class_body_declarations_opt = 
			{
					 return new List();
			}
			case 666: // class_body_declarations_opt = class_body_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 667: // pt_inst_decl_opt_list = 
			{
					 return new List();
			}
			case 668: // pt_inst_decl_opt_list = pt_inst_decl_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 669: // pt_inst_decl_list = pt_inst_decl.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final PTInstDecl n = (PTInstDecl) _symbol_n.value;
					 return new List().add(n);
			}
			case 670: // pt_inst_decl_list = pt_inst_decl_list.l pt_inst_decl.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final PTInstDecl n = (PTInstDecl) _symbol_n.value;
					 return l.add(n);
			}
			case 671: // element_value_pairs_opt = 
			{
					 return new List();
			}
			case 672: // element_value_pairs_opt = element_value_pairs.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 673: // pt_simple_declaration_opt_list = 
			{
					 return new List();
			}
			case 674: // pt_simple_declaration_opt_list = pt_simple_declaration_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 675: // pt_simple_declaration_list = pt_simple_declaration.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SimpleClass n = (SimpleClass) _symbol_n.value;
					 return new List().add(n);
			}
			case 676: // pt_simple_declaration_list = pt_simple_declaration_list.l pt_simple_declaration.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final SimpleClass n = (SimpleClass) _symbol_n.value;
					 return l.add(n);
			}
			case 677: // throws_opt = 
			{
					 return new List();
			}
			case 678: // throws_opt = throws.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 679: // for_init_opt = 
			{
					 return new List();
			}
			case 680: // for_init_opt = for_init.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 681: // formal_parameter_list_opt = 
			{
					 return new List();
			}
			case 682: // formal_parameter_list_opt = formal_parameter_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 683: // for_update_opt = 
			{
					 return new List();
			}
			case 684: // for_update_opt = for_update.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 685: // pt_declaration_list = pt_declaration.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final PTDecl n = (PTDecl) _symbol_n.value;
					 return new List().add(n);
			}
			case 686: // pt_declaration_list = pt_declaration_list.l pt_declaration.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final PTDecl n = (PTDecl) _symbol_n.value;
					 return l.add(n);
			}
			case 353: // annotation_type_element_declaration = constant_declaration.constant_declaration
			case 360: // modifier = annotation.annotation
			case 361: // annotation = normal_annotation.normal_annotation
			case 362: // annotation = marker_annotation.marker_annotation
			case 363: // annotation = single_element_annotation.single_element_annotation
			case 616: // expression_nn = assignment_expression_nn.assignment_expression_nn
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
