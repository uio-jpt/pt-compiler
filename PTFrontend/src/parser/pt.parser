/* NB: Remember to clean/rebuild. The parser will behave strange otherwise.
*/

/* Solving the internal interface problem seems somewhat tricky.
   Do we need a wrapper class for interface declarations, like
   PTClassDecl for normal classes? Should it inherit from
   SimpleClass even though it's technically not exactly a class?
   Otherwise, are there any problems with renaming something
   that's not a SimpleClass?
    -svk

   The way it's done now: we have a very shallow wrapper class,
   PTInterfaceDecl, which I believe is useful for renaming,
   but that might be wrong. SimpleClass is not involved, so
   a lot of methods that previously returned SimpleClass now
   return TypeDecl, and casts are required later after checking
   with instanceof. I believe I've fixed this up so it _works_,
   but many method/variable names should be updated for
   readability, assuming this stays.
*/

CompilationUnit compilation_unit =
package_declaration.p import_declarations.i? pt_declaration.pt+ {: return new PTCompilationUnit(p.getID(), i, new List<TypeDecl>(), pt); :}
| import_declarations.i? pt_declaration.pt+ {: return new PTCompilationUnit("", i, new List<TypeDecl>(), pt); :}
;

PTDecl pt_declaration =
  pt_template.t
  {: return t; :}
| pt_package.p
  {: return p; :}
;

PTDecl pt_template =
 TEMPLATE IDENTIFIER LBRACE inst_class_or_interface_single.l+ RBRACE
          {:
                AST.List<SimpleClass> simpleClassList = new AST.List<SimpleClass>();
                AST.List<PTInstDecl> instDeclList = new AST.List<PTInstDecl>();
                AST.List<PTInterfaceDecl> intfDeclList = new AST.List<PTInterfaceDecl>();

                for (int i=0; i<l.getNumChildNoTransform(); i++) {
                    ASTNode n = l.getChildNoTransform(i);
                    if (n instanceof PTInstDecl) {
                        instDeclList.add( (PTInstDecl) n);
                    }
                    else if (n instanceof PTInterfaceDecl) {
                        intfDeclList.add( (PTInterfaceDecl) n );
                    }
                    else {
                        simpleClassList.add( (SimpleClass) n);
                    }
                }
                return new PTTemplate(IDENTIFIER, instDeclList, simpleClassList, intfDeclList);
          :}
          ;

    // xx code duplication with above
PTDecl pt_package =
 PACKAGE IDENTIFIER LBRACE inst_class_or_interface_single.l* RBRACE
          {:
                AST.List<SimpleClass> simpleClassList = new AST.List<SimpleClass>();
                AST.List<PTInstDecl> instDeclList = new AST.List<PTInstDecl>();
                AST.List<PTInterfaceDecl> intfDeclList = new AST.List<PTInterfaceDecl>();

                for (int i=0; i<l.getNumChildNoTransform(); i++) {
                    ASTNode n = l.getChildNoTransform(i);
                    if (n instanceof PTInstDecl) {
                        instDeclList.add( (PTInstDecl) n);
                    }
                    else if (n instanceof PTInterfaceDecl) {
                        intfDeclList.add( (PTInterfaceDecl) n );
                    }
                    else {
                        simpleClassList.add( (SimpleClass) n);
                    }
                }
                return new PTPackage(IDENTIFIER, instDeclList, simpleClassList, intfDeclList);
          :}
          ;

ASTNode inst_class_or_interface_single =
     pt_inst_decl.pt_inst {: return pt_inst; :}
   | class_or_interface_single.x {: return x; :}
   ;

ASTNode class_or_interface_single =
     pt_simple_declaration.pt_class {: return pt_class; :}
   | pt_intf_decl.intf_decl {: return intf_decl; :}
   ;


SimpleClass pt_simple_declaration =
  pt_class_declaration.cd
              {: return new PTClassDecl(cd); :}
| pt_adds_class.pt_ac 
              {: return new PTClassAddsDecl(pt_ac); :}
;

PTInstDecl pt_inst_decl =
  INST IDENTIFIER SEMICOLON
       {: return new PTInstDecl(IDENTIFIER, new List()); :}
| INST IDENTIFIER WITH dummy_class_list.dcl SEMICOLON
       {: return new PTInstDecl(IDENTIFIER, dcl); :}
;

List dummy_class_list =
      dummy_class_list.dcl COMMA dummy_inst_tuple.t {: return dcl.add(t); :}
    | dummy_inst_tuple.t {: return new List().add(t); :}
    ;

PTInstTuple dummy_inst_tuple =
    IDENTIFIER.a RIGHTARROW IDENTIFIER.b 
    dummy_inst_tuple_rename_list_opt.l
    {: return new PTInstTuple(a,b,l); :}
    ;

List dummy_inst_tuple_rename_list_opt =
      LPAREN dummy_inst_tuple_rename_list.l RPAREN {: return l; :}
    | {: return new List(); :}
    ;

List dummy_inst_tuple_rename_list =
      dummy_inst_tuple_rename_list.l 
      COMMA definition_renaming.dr {: return l.add(dr); :}
    | definition_renaming.dr {: return new List().add(dr); :}
    ;

List def_opt_rename_params =
      def_rename_params_list.l {: return l; :}
    | {: return new List(); :}
    ;

List def_rename_params_list =
      def_rename_params_list.l 
      COMMA type.t {: return l.add(t); :}
    | type.t {: return new List().add(t); :}
    ;
    

PTDummyRename definition_renaming =
        IDENTIFIER.a SIMPLERIGHTARROW IDENTIFIER.b {: return new PTFieldRename(a,b); :}
      | IDENTIFIER.a ASTERISK_PAR  SIMPLERIGHTARROW IDENTIFIER.b {: return new PTMethodRenameAll(a,b); :}        
      | IDENTIFIER.a LPAREN def_opt_rename_params.pl RPAREN  SIMPLERIGHTARROW IDENTIFIER.b {: return new PTMethodRename(a,b,pl); :}
;

ClassDecl pt_adds_class = 
  CLASS IDENTIFIER ADDS class_body.b
    {: return new ClassDecl(new Modifiers(), IDENTIFIER, new Opt(), new List(), b); :}
  ;

PTInterfaceDecl pt_intf_decl =
  modifiers.m? INTERFACE IDENTIFIER extends_interfaces.i? interface_body.b {: return new PTInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b); :}
  ;

ClassDecl pt_class_declaration =
    modifiers.m? CLASS IDENTIFIER super.s? interfaces.i? class_body.b 
                                               {: return new ClassDecl(new Modifiers(m), IDENTIFIER, s, i, b); :}
  ;
  

Access method_invocation =  explicit_merged_method_invocation.e {: return e; :}
;

Access explicit_merged_method_invocation =
     TSUPER LBRACK IDENTIFIER.superClassName RBRACK merged_method_name.methodName LPAREN argument_list.args? RPAREN
     {:
        TemplateMethodAccessShort m = new TemplateMethodAccessShort(methodName, args, superClassName, "");
        m.setStart(TSUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m; :}
    ;

Access explicit_merged_method_invocation =
     TSUPER LBRACK IDENTIFIER.templateName DOT IDENTIFIER.superClassName RBRACK merged_method_name.methodName LPAREN argument_list.args? RPAREN
     {:
        TemplateMethodAccess m = new TemplateMethodAccess(javaworld.Util.toName(templateName,superClassName,methodName), args, superClassName, templateName);
        m.setStart(TSUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m; :}
    ;


String merged_method_name =
      DOT IDENTIFIER {: return IDENTIFIER; :}
    ;

MethodDecl method_header =
    TABSTRACT modifiers.m? type.t IDENTIFIER LPAREN formal_parameter_list.l? RPAREN dims.d? throws.tl?
    {: return new TabstractMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt()); :}
  | TABSTRACT modifiers.m? VOID   IDENTIFIER LPAREN formal_parameter_list.l? RPAREN throws.tl?
    {: return new TabstractMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt()); :}
  ;
