/* NB: Remember to clean/rebuild. The parser will behave strange otherwise.
*/

/* Mhp templatparametre er korrekt parsing av dette tilsynelatende (ut fra
   hvordan det er løst i JastAddJ) litt vanskelig, grunnet trøbbel med
   at f.eks. < etterfulgt av < blir <<, som er et annet token (shift).
   Dette er et kjent problem på brukernivå fra C++, men i Java må
   parseren altså tydeligvis leve med dette. Prøver derfor så langt som
   det er mulig å gjenbruke de allerede eksisterende produksjonene
   for type_arguments (aktualparametre) og type_parameters (formalparametre).
*/

/* Erfaring som kan være nyttig under debugging når man legger til
   nye type-lignende ting: JastAdd bruker konvensjonen for navnesjekking
   at hvert navn sjekker at
        extractSingleType(lookupType(this.name())) == this
   eller lignende. Dette er en sjekk for multippeldeklarasjon (det antas
   at extractSingleType er deterministisk så hvis to typer har samme navn
   i samme skop kan dette ikke holde for begge).

   Imidlertid: når man legger inn nye typer, før man har lagt inn den
   nødvendige koden for å la lookupType finne disse, vil lookupType()
   returnere null, som heller ikke er this. JastAdd vil da gi en
   forvirrende feilmelding om at noe er multippelt deklarert; problemet
   kan da altså også være at det ikke engang selv er synlig i sitt
   eget skop, selv om det har et unikt navn.

   Jastadd "finner" typedeklarasjonene som skal navnesjekkes ved å
   gå igjennom hele treet, og en trenger ikke å gjøre noe spesielt
   for at de nye typene en legger til skal finnes igjen. Derfor får
   en gjerne denne feilmeldingen når en legger til en ny type, før
   den er skikkelig implementert.
*/

CompilationUnit compilation_unit =
package_declaration.p import_declarations.i? pt_declaration.pt+ {: return new PTCompilationUnit(p.getID(), i, new List<TypeDecl>(), pt); :}
| import_declarations.i? pt_declaration.pt+ {: return new PTCompilationUnit("", i, new List<TypeDecl>(), pt); :}
;

PTDecl pt_declaration =
  pt_template.t
  {: return t; :}
| pt_package.p
  {: return p; :}
;

Modifier modifier =
    TABSTRACT {: return new Modifier("tabstract"); :}
    ;

PTDecl pt_template =
 TEMPLATE IDENTIFIER LBRACE inst_class_or_interface_single.l+ RBRACE
          {:
                javaworld.ChildClassifier cc = new javaworld.ChildClassifier( l );
                return new PTTemplate(IDENTIFIER,
                                      cc.getInstDecls(),
                                      cc.getSimpleClasses(),
                                      cc.getInterfaces(),
                                      cc.getEnums(),
                                      new AST.List<AST.TypeVariable>()
                                      );
          :}
 | TEMPLATE IDENTIFIER type_parameters.ps LBRACE inst_class_or_interface_single.l+ RBRACE
          {:
                javaworld.ChildClassifier cc = new javaworld.ChildClassifier( l );
                if( ps != null ) {
                    for( Object o : ps ) {
                        System.out.println( "Got type parameter, class: " + o.getClass().getName() );
                    }
                }
                return new PTTemplate(IDENTIFIER,
                                      cc.getInstDecls(),
                                      cc.getSimpleClasses(),
                                      cc.getInterfaces(),
                                      cc.getEnums(),
                                      ps
                                      );
          :}
          ;

PTDecl pt_package =
 PACKAGE IDENTIFIER LBRACE inst_class_or_interface_single.l* RBRACE
          {:
                javaworld.ChildClassifier cc = new javaworld.ChildClassifier( l );
                return new PTPackage(IDENTIFIER, cc.getInstDecls(), cc.getSimpleClasses(), cc.getInterfaces(), cc.getEnums());
          :}
          ;

ASTNode inst_class_or_interface_single =
     pt_inst_decl.pt_inst {: return pt_inst; :}
   | class_or_interface_single.x {: return x; :}
   ;

ASTNode class_or_interface_single =
     pt_simple_declaration.pt_class {: return pt_class; :}
   | pt_intf_decl.intf_decl {: return intf_decl; :}
   | pt_enum_declaration.enum_decl {: return enum_decl; :}
   ;

PTEnumDecl pt_enum_declaration =
    // denne er muligens overflødig.. trenger vi å gjøre noe med enums?
    modifiers.m? ENUM IDENTIFIER.id interfaces.i? enum_body.b
    {: return new PTEnumDecl(new Modifiers(m), id, i, b); :}
    ;

SimpleClass pt_simple_declaration =
  class_declaration.cd
              {: return new PTClassDecl(cd); :}
| pt_adds_class.pt_ac 
              {: return new PTClassAddsDecl(pt_ac); :}
;

PTInstDecl pt_inst_decl =
  INST IDENTIFIER SEMICOLON
       {: return new PTInstDecl(IDENTIFIER, new List()); :}
| INST IDENTIFIER WITH dummy_class_list.dcl SEMICOLON
       {: return new PTInstDecl(IDENTIFIER, dcl); :}
;

List dummy_class_list =
      dummy_class_list.dcl COMMA dummy_inst_tuple.t {: return dcl.add(t); :}
    | dummy_inst_tuple.t {: return new List().add(t); :}
    ;

PTInstTuple dummy_inst_tuple =
    IDENTIFIER.a RIGHTARROW IDENTIFIER.b 
    dummy_inst_tuple_rename_list_opt.l
    {: return new PTInstTuple(a,b,l); :}
    ;

List dummy_inst_tuple_rename_list_opt =
      LPAREN dummy_inst_tuple_rename_list.l RPAREN {: return l; :}
    | {: return new List(); :}
    ;

List dummy_inst_tuple_rename_list =
      dummy_inst_tuple_rename_list.l 
      COMMA definition_renaming.dr {: return l.add(dr); :}
    | definition_renaming.dr {: return new List().add(dr); :}
    ;

List def_opt_rename_params =
      def_rename_params_list.l {: return l; :}
    | {: return new List(); :}
    ;

List def_rename_params_list =
      def_rename_params_list.l 
      COMMA type.t {: return l.add(t); :}
    | type.t {: return new List().add(t); :}
    ;
    

PTDummyRename definition_renaming =
        IDENTIFIER.a SIMPLERIGHTARROW IDENTIFIER.b {: return new PTFieldRename(a,b); :}
      | IDENTIFIER.a ASTERISK_PAR  SIMPLERIGHTARROW IDENTIFIER.b {: return new PTMethodRenameAll(a,b); :}        
      | IDENTIFIER.a LPAREN def_opt_rename_params.pl RPAREN  SIMPLERIGHTARROW IDENTIFIER.b {: return new PTMethodRename(a,b,pl); :}
;

ClassDecl pt_adds_class = 
  CLASS IDENTIFIER ADDS class_body.b
    {: return new ClassDecl(new Modifiers(), IDENTIFIER, new Opt(), new List(), b); :}
  ;


PTInterfaceDecl pt_intf_decl =
  modifiers.m? INTERFACE IDENTIFIER extends_interfaces.i? interface_body.b {: return new PTInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b); :}
  ;

Access method_invocation =  explicit_merged_method_invocation.e {: return e; :}
;

Access explicit_merged_method_invocation =
     TSUPER LBRACK IDENTIFIER.superClassName RBRACK merged_method_name.methodName LPAREN argument_list.args? RPAREN
     {:
        TemplateMethodAccessShort m = new TemplateMethodAccessShort(methodName, args, superClassName, "");
        m.setStart(TSUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m; :}
    ;

Access explicit_merged_method_invocation =
     TSUPER LBRACK IDENTIFIER.templateName DOT IDENTIFIER.superClassName RBRACK merged_method_name.methodName LPAREN argument_list.args? RPAREN
     {:
        TemplateMethodAccess m = new TemplateMethodAccess(javaworld.Util.toName(templateName,superClassName,methodName), args, superClassName, templateName);
        m.setStart(TSUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m; :}
    ;


String merged_method_name =
      DOT IDENTIFIER {: return IDENTIFIER; :}
    ;
