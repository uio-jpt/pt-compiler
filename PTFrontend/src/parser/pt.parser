/* NB: Remember to clean/rebuild. The parser will behave strange otherwise.
*/

/* Solving the internal interface problem seems somewhat tricky.
   Do we need a wrapper class for interface declarations, like
   PTClassDecl for normal classes? Should it inherit from
   SimpleClass even though it's technically not exactly a class?
   Otherwise, are there any problems with renaming something
   that's not a SimpleClass?
    -svk

   The way it's done now: we have a very shallow wrapper class,
   PTInterfaceDecl, which I believe is useful for renaming,
   but that might be wrong. SimpleClass is not involved, so
   a lot of methods that previously returned SimpleClass now
   return TypeDecl, and casts are required later after checking
   with instanceof. I believe I've fixed this up so it _works_,
   but many method/variable names should be updated for
   readability, assuming this stays.
*/

CompilationUnit compilation_unit =
package_declaration.p import_declarations.i? pt_declaration.pt+ {: return new PTCompilationUnit(p.getID(), i, new List<TypeDecl>(), pt); :}
| import_declarations.i? pt_declaration.pt+ {: return new PTCompilationUnit("", i, new List<TypeDecl>(), pt); :}
;

PTDecl pt_declaration =
  pt_template.t
  {: return t; :}
| pt_package.p
  {: return p; :}
;

Modifier modifier =
    TABSTRACT {: return new Modifier("tabstract"); :}
    ;

PTDecl pt_template =
 TEMPLATE IDENTIFIER LBRACE inst_class_or_interface_single.l+ RBRACE
          {:
                AST.List<SimpleClass> simpleClassList = new AST.List<SimpleClass>();
                AST.List<PTInstDecl> instDeclList = new AST.List<PTInstDecl>();
                AST.List<PTInterfaceDecl> intfDeclList = new AST.List<PTInterfaceDecl>();

                for (int i=0; i<l.getNumChildNoTransform(); i++) {
                    ASTNode n = l.getChildNoTransform(i);
                    if (n instanceof PTInstDecl) {
                        instDeclList.add( (PTInstDecl) n);
                    }
                    else if (n instanceof PTInterfaceDecl) {
                        intfDeclList.add( (PTInterfaceDecl) n );
                    }
                    else if(n instanceof PTEnumDecl ) {
                        System.out.println( "warning: ignoring enum \"" + n.getId() + "\"" );
                    }
                    else if(n instanceof SimpleClass ) {
                        simpleClassList.add( (SimpleClass) n);
                    } else {
                        throw new IllegalStateException( "child of ptdecl could not be classified" );
                    }
                }

                return new PTTemplate(IDENTIFIER, instDeclList, simpleClassList, intfDeclList);
          :}
          ;

    // xx code duplication with above
PTDecl pt_package =
 PACKAGE IDENTIFIER LBRACE inst_class_or_interface_single.l* RBRACE
          {:
                AST.List<SimpleClass> simpleClassList = new AST.List<SimpleClass>();
                AST.List<PTInstDecl> instDeclList = new AST.List<PTInstDecl>();
                AST.List<PTInterfaceDecl> intfDeclList = new AST.List<PTInterfaceDecl>();

                for (int i=0; i<l.getNumChildNoTransform(); i++) {
                    ASTNode n = l.getChildNoTransform(i);
                    if (n instanceof PTInstDecl) {
                        instDeclList.add( (PTInstDecl) n);
                    }
                    else if (n instanceof PTInterfaceDecl) {
                        intfDeclList.add( (PTInterfaceDecl) n );
                    }
                    else if(n instanceof PTEnumDecl ) {
                        System.out.println( "warning: ignoring enum \"" + n.getId() + "\"" );
                    }
                    else if(n instanceof SimpleClass ) {
                        simpleClassList.add( (SimpleClass) n);
                    } else {
                        throw new IllegalStateException( "child of ptdecl could not be classified" );
                    }
                }

                return new PTPackage(IDENTIFIER, instDeclList, simpleClassList, intfDeclList);
          :}
          ;

ASTNode inst_class_or_interface_single =
     pt_inst_decl.pt_inst {: return pt_inst; :}
   | class_or_interface_single.x {: return x; :}
   ;

ASTNode class_or_interface_single =
     pt_simple_declaration.pt_class {: return pt_class; :}
   | pt_intf_decl.intf_decl {: return intf_decl; :}
   | pt_enum_declaration.enum_decl {: return enum_decl; :}
   ;

PTEnumDecl pt_enum_declaration =
    // denne er muligens overflødig.. trenger vi å gjøre noe med enums?
    modifiers.m? ENUM IDENTIFIER.id interfaces.i? enum_body.b
    {: return new PTEnumDecl(new Modifiers(m), id, i, b); :}
    ;

SimpleClass pt_simple_declaration =
  class_declaration.cd
              {: return new PTClassDecl(cd); :}
| pt_adds_class.pt_ac 
              {: return new PTClassAddsDecl(pt_ac); :}
;

PTInstDecl pt_inst_decl =
  INST IDENTIFIER SEMICOLON
       {: return new PTInstDecl(IDENTIFIER, new List()); :}
| INST IDENTIFIER WITH dummy_class_list.dcl SEMICOLON
       {: return new PTInstDecl(IDENTIFIER, dcl); :}
;

List dummy_class_list =
      dummy_class_list.dcl COMMA dummy_inst_tuple.t {: return dcl.add(t); :}
    | dummy_inst_tuple.t {: return new List().add(t); :}
    ;

PTInstTuple dummy_inst_tuple =
    IDENTIFIER.a RIGHTARROW IDENTIFIER.b 
    dummy_inst_tuple_rename_list_opt.l
    {: return new PTInstTuple(a,b,l); :}
    ;

List dummy_inst_tuple_rename_list_opt =
      LPAREN dummy_inst_tuple_rename_list.l RPAREN {: return l; :}
    | {: return new List(); :}
    ;

List dummy_inst_tuple_rename_list =
      dummy_inst_tuple_rename_list.l 
      COMMA definition_renaming.dr {: return l.add(dr); :}
    | definition_renaming.dr {: return new List().add(dr); :}
    ;

List def_opt_rename_params =
      def_rename_params_list.l {: return l; :}
    | {: return new List(); :}
    ;

List def_rename_params_list =
      def_rename_params_list.l 
      COMMA type.t {: return l.add(t); :}
    | type.t {: return new List().add(t); :}
    ;
    

PTDummyRename definition_renaming =
        IDENTIFIER.a SIMPLERIGHTARROW IDENTIFIER.b {: return new PTFieldRename(a,b); :}
      | IDENTIFIER.a ASTERISK_PAR  SIMPLERIGHTARROW IDENTIFIER.b {: return new PTMethodRenameAll(a,b); :}        
      | IDENTIFIER.a LPAREN def_opt_rename_params.pl RPAREN  SIMPLERIGHTARROW IDENTIFIER.b {: return new PTMethodRename(a,b,pl); :}
;

ClassDecl pt_adds_class = 
  CLASS IDENTIFIER ADDS class_body.b
    {: return new ClassDecl(new Modifiers(), IDENTIFIER, new Opt(), new List(), b); :}
  ;


PTInterfaceDecl pt_intf_decl =
  // overflødig ?!
  /* hm, hvordan da? rent direkte, ikketerminalen brukes på linje 92, i class_or_interface_single (kunne
     jo bare inlina den der, men synes dette er ryddigere, siden den er lang)

     om du mener at PTInterfaceDecl er overflødig og at vi bare kunne brukt InterfaceDecl i stedet, kanskje;
     har ikke tenkt helt igjennom det, men PTInterfaceDecl arver jo direkte fra InterfaceDecl, så det er ikke
     noe særlig ekstra trøbbel. det er ikke helt trivielt at vi bare kan kutte ut PTInterfaceDecl; selv om
     den ikke legger til noen nye metoder eller variabler, bruker vi "instanceof PTInterfaceDecl" noen steder
     i koden. dette sjekker vel at vi bare finner interfaces som vi har laget her (altså som er barn av
     en templat eller en PT-package, noe vi senere kan bruke ved å kalle getParentClass). om PTInterfaceDecl
     er overflødig vil det vel være fordi vi på en eller annen måte kan vise at denne sjekken er overflødig
     og aldri vil slå feil, men hvorfor ikke være eksplisitt? dessuten gir dette oss mulighet til å legge til
     util-metoder i PTInterfaceDecl med et jastadd-aspekt.
        -svk
  */
  modifiers.m? INTERFACE IDENTIFIER extends_interfaces.i? interface_body.b {: return new PTInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b); :}
  ;

Access method_invocation =  explicit_merged_method_invocation.e {: return e; :}
;

Access explicit_merged_method_invocation =
     TSUPER LBRACK IDENTIFIER.superClassName RBRACK merged_method_name.methodName LPAREN argument_list.args? RPAREN
     {:
        TemplateMethodAccessShort m = new TemplateMethodAccessShort(methodName, args, superClassName, "");
        m.setStart(TSUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m; :}
    ;

Access explicit_merged_method_invocation =
     TSUPER LBRACK IDENTIFIER.templateName DOT IDENTIFIER.superClassName RBRACK merged_method_name.methodName LPAREN argument_list.args? RPAREN
     {:
        TemplateMethodAccess m = new TemplateMethodAccess(javaworld.Util.toName(templateName,superClassName,methodName), args, superClassName, templateName);
        m.setStart(TSUPER.getStart());
        m.setEnd(RPAREN.getEnd());
        return m; :}
    ;


String merged_method_name =
      DOT IDENTIFIER {: return IDENTIFIER; :}
    ;
